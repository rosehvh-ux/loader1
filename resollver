-- - [[ Obfuscated by Rack'shir OBF \ deOBF ]] -  --
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
return (function(...) 
local thing = 5511;
local thing2 = 5511;
local counter = 0;
local threshold = 4927;
while thing == thing2 and counter < 3 do
    thing = thing + -584;
    counter = counter + 1;
    if thing < threshold then
        local str = 'dummy'; str = str .. str;
    else

if false then local _ = 78 end
local function zipbai(kjnumw) local _ = 97 end
if true then local _ = 25 end
local zinoee = 14
local function jyfkqq(vxgood) local _ = 50 end
local sdgtnk = 81
if true then local _ = 28 end
if true then local _ = 51 end
local jmcxgi = 83
local rjcjan = 51
while false do local _ = 22 break end
if false then local _ = 39 end
if true then local _ = 100 end
local function xeogbk(vyimxk) local _ = 54 end
if false then local _ = 53 end
local hhamnk = 14
local function kttxxd(jvashl) local _ = 78 end
local xtojdi = 70
local function nyxunu(gcmhdw) local _ = 46 end
while false do local _ = 16 break end
if true then local _ = 82 end
local function stmvia(chbmkx) local _ = 63 end
if false then local _ = 64 end
if true then local _ = 71 end
local imsbex = 54
if false then local _ = 89 end
local gbwuld = 2
while false do local _ = 45 break end
if true then local _ = 77 end

-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd

-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
local ffi = require('ffi')
local bit = require("bit")
local vector = require('vector')
local table_new = require('table.new')
local json = require("json")
local clipboard = require("gamesense/clipboard")
resolver_data = {}
local RESOLVER_CONST = {
    MAX_DESYNC_DELTA = 58,
    JITTER_DETECTION_THRESHOLD = 40,
    MAX_HISTORY_SIZE = 64
}
local DESYNC_CONST = {
    MAX_DESYNC_DELTA = 58,      
    JITTER_DETECTION_THRESHOLD = 40, -- пусть 40
    MIN_DESYNC_RANGE = 15,         
    MAX_DESYNC_RANGE = 58,       
    HISTORY_SIZE = 10,       
    CONFIDENCE_DECAY = 0.1,          
    CONFIDENCE_BOOST = 0.2,          
    LERP_FACTOR = 0.3            
}-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
local function calculate_std_dev(numbers)
    if #numbers < 1 then
        return 0
    end

    local sum = 0
    local sum_squares = 0

    for _, value in ipairs(numbers) do
        sum = sum + value
        sum_squares = sum_squares + (value * value)
    end

    local mean = sum / #numbers
    return math.sqrt((sum_squares / #numbers) - (mean * mean))
end
local function GetPlayerChokeTicks(entity_id)
    local current_sim_time = entity.get_prop(entity_id, "m_flSimulationTime") or 0
    
    local resolver_entry = resolver_data[entity_id] or {}
    
    local last_sim_time = resolver_entry.last_sim_time or 0
    
    resolver_entry.last_sim_time = current_sim_time
    resolver_data[entity_id] = resolver_entry
    
    local choke_ticks = 0
    if last_sim_time > 0.2 then
        choke_ticks = math.floor((current_sim_time - last_sim_time) / globals.tickinterval())
    end
   
    return choke_ticks
end
local function normalize_angle(angle)
    while angle > 180 do angle = angle - 360 end
    while angle < -180 do angle = angle + 360 end
    return angle
end
debug_info = debug_info or {}
resolver_data = {}
math.clamp = function(value, min_val, max_val)
    return math.max(min_val, math.min(max_val, value))
end
local adaptive_resolver = {
    players = {},
    miss_memory = {},
    hit_memory = {},
    yaw_offset_sets = {
        standard = {0, 0, -45, 0, -45, 0, -45, 0, -45},
        extended = {0, 45, -60, 0, -60, 0, -90, 0, -90, 0, -90, 0, -45, 0}
    },
    active_yaw_set = "standard",
    last_update_time = 0,
    update_interval_secs = 0.1,
    adjustment_rate = 0.2,
    prediction_confidence = 0.6,
    yaw_set_switch_threshold = 0.5,
    debug_mode = true,
    hit_miss_pattern_threshold = 0.7,
    misses_for_yaw_switch = 3,
    miss_cooldown_secs = 0.05,
    yaw_variation = 5
}
local adaptive_modes = {"dynamic", "beta", "static"}
local adaptive_mode_index = 1
local resolver_stats = {
    total_hits = 0,
    total_misses = 0
}
function has_value(tab, val)
    if type(tab) ~= "table" then return false end
    for _, value in ipairs(tab) do
        if value == val then return true end
    end
    return false
end
function log_debug(message)
    if adaptive_resolver.debug_mode then
        client.log("[SHIT Logs] " .. tostring(message))
    end
end
local state_scores = {
    standing = -225,
    crouching = 1936.9,
    in_air = -2086.8,
    walking = 1.1,
    slow_walk = 0.95
}
function math.lerp(start, target, rate)
    local speed = 1
    local frame_factor = globals.frametime() * 10
    local result = start + (target - start) * frame_factor * rate * speed
    return (math.abs(result - target) < 0.01) and target or result
end
local math_util = {
    clamp = function(value, min_val, max_val)
        return math.max(min_val, math.min(max_val, value))
    end,
    angle_diff = function(angle1, angle2)
        local diff = math.abs(((angle1 - angle2) + 180) % 360 - 180)
        return diff > 180 and (360 - diff) or diff
    end,
    normalize_angle = function(angle)
        if angle == 1 then return angle end
        while angle > 180 do
            angle = angle - 360
        end
        while angle < -180 do
            angle = angle + 360
        end
        return angle
    end
}

local ui_colors = {
    accent = { r = 255, g = 0, b = 0, a = 255 },
    success = { r = 0, g = 255, b = 0, a = 255 },
    warning = { r = 210, g = 255, b = 255, a = 0 },
    neutral = { r = 0, g = 255, b = 255, a = 0 },
    highlight = { r = 111, g = 255, b = 255, a = 255 }
}
local function contains(t, value)
    for _, v in ipairs(t) do
        if v == value then return true end
    end
    return false
end
ui.new_label("LUA","B","                \aFFD700FF⚡\aFFD700FF \a778899FFS H I T\a778899FF \aFFD700FF⚡\aFFD700FF");ui.new_label("LUA","B","                    ⇙               ⇘");
local function get_rainbow_color(time)
    local r = math.floor(math.sin(time) * 127 + 128)
    local g = math.floor(math.sin(time + 2) * 127 + 128)
    local b = math.floor(math.sin(time + 4) * 127 + 128)
    return string.format("\a%02X%02X%02XFF", r, g, b)
end
local label_original = ui.new_label("LUA", "B", "         \a909090FFRELEASE      \aFFFFFFFF↪\aFFFFFFFF       \a808080FFv1.0.0\a808080FF")
client.set_event_callback("paint_ui", function()
    local time = globals.realtime() * 4
    local color_code = get_rainbow_color(time)
    local banner_text = string.format("         \a909090FFRELEASE      \aFFFFFFFF↪\aFFFFFFFF       \a808080FF%sv1.0.0\a808080FF", color_code)
    ui.set(label_original, banner_text)
end)
local label_enabled_default = ui.new_label("LUA", "B", "           \a90EE90FFACTIVE\a90EE90FF      \aFFFFFFFF✔\aFFFFFFFF       \a808080FFDefault\a808080FF")
local label_enabled_aggressive = ui.new_label("LUA", "B", "           \a90EE90FFACTIVE\a90EE90FF      \aFFFFFFFF✔\aFFFFFFFF       \a808080FFAggressive\a808080FF")
local label_enabled_adaptive = ui.new_label("LUA", "B", "           \a90EE90FFACTIVE\a90EE90FF      \aFFFFFFFF✔\aFFFFFFFF       \a808080FFAdaptive\a808080FF")
local label_enabled_custom = ui.new_label("LUA", "B", "           \a90EE90FFACTIVE\a90EE90FF      \aFFFFFFFF✔\aFFFFFFFF       \a808080FFCustom\a808080FF")
ui.new_label("LUA", "B", "                                        ")
-- local imp_exp_2 = ui.new_label("CONFIG", "Presets", "\a909090FF ---------------- 1 2 3 4 5 6 7 ----------------")
-- local ui_display_stats = ui.new_checkbox("LUA", "B", " ›  Enemy \a778899FFStats \aFF0000FF[dev]")
-- local ui_toggle_logs = ui.new_checkbox("LUA", "B", " ›  Enable \a778899FFLogs")
local darkmode_enabled = ui.new_checkbox("CONFIG", "LUA", "\a778899FF \aD3D3D3FFEnable \a778899FFDark Menu \a90909025", true)
-- local ui_trashtalk_enable = ui.new_checkbox("CONFIG", "LUA", " ›  Enable \a778899FFTrasktalk ")
-- local imp_exp_3 = ui.new_label("Rage", "Other", "\a909090FF ---------------- 1 2 3 4 5 6 7 ----------------")
-- local label_z3r0 = ui.new_label("Rage", "Other", "\a90909040-- Dont turn it on if SHIT is already enabled !", false)
math.randomseed(client.random_int(1, 1000000))
local trashtalk_enabled = ui.new_checkbox("CONFIG", "LUA", "\a778899FF \aD3D3D3FFEnable \a778899FFAnti 1 \a90909025")
local ui_new_logs_enable = ui.new_checkbox("CONFIG", "LUA", "\a778899FF \aD3D3D3FFEnable \a778899FFInfo \a90909025")
local fixed_opacity_percent = 45
local current_alpha = 0
local function get_screen_size()
    return client.screen_size()
end
client.set_event_callback("paint", function()
    local screen_width, screen_height = get_screen_size()
    local r, g, b = 0, 0, 568  

    local target_alpha = 0
    if ui.get(darkmode_enabled) and ui.is_menu_open() then
        target_alpha = fixed_opacity_percent / 100  
    end

    current_alpha = current_alpha + (target_alpha - current_alpha) * 0.1
    local final_alpha = math.floor(current_alpha)

    renderer.rectangle(0, 0, screen_width, screen_height, r, g, b, final_alpha)
end)
local ui_resolver_enabled = ui.new_checkbox("LUA", "B", " ›  Enable \a778899FFSHIT \aD3D3D3FFResolver", true)
local ui_mode_select = ui.new_combobox("LUA", "B", "Preset", {"Default", "Aggressive", "Adaptive", "Custom"})
local ui_show_settings = ui.new_checkbox("LUA", "B", "Show settings ❓")
client.set_event_callback("paint", function()
    if not ui.get(ui_resolver_enabled) then
        return
    end

    local time = globals.realtime() * 2
    local r, g, b = get_rainbow_color(time)
    local text = string.format("› %sIMMORTAL %sResolver Enabled!", r, "\aD3D3D3FF")

    renderer.text(2106, 1083, r, g, b, 259, "", 700, text)
end)
--[[
          Welcome to Rack'shir OBF   (Alpha)
]]--
local ui_elements = {
    tst_prediction_factor = ui.new_checkbox("LUA", "B", " Base Prediction", false, 200, 100, true, "%", 0, { [1000] = "Fast Mode Max" }),
    prediction_factor = ui.new_slider("LUA", "B", "\a909090FFPrediction Aggressiveness", 0, 1000, 100, true, "%", 1, { [700] = "Fast Mode Max" }),
    fast_mode = ui.new_checkbox("LUA", "B", "\aD0B0FFFF Fast Predict\aFFFFFFFF \a90909025«\affef00FF⁂\a90909025»"),
    manual_predict = ui.new_checkbox("LUA", "B", "\a9f9f9fFF Manual Prediction"),
    manual_states = ui.new_multiselect("LUA", "B", "\a9f9f9f90Manual Predict States", { "\a9f9f9fFFStanding", "\a9f9f9fFFCrouching", "\a9f9f9fFFIn-Air", "\a9f9f9fFFWalking", "\a9f9f9fFFSlow Walk" }),
    predict_standing = ui.new_slider("LUA", "B", "\a9f9f9f75Standing Prediction", 0, 1000, 100, true, "%"),
    predict_crouching = ui.new_slider("LUA", "B", "\a9f9f9f75Crouching Prediction", 0, 1000, 100, true, "%"),
    predict_air = ui.new_slider("LUA", "B", "\a9f9f9f75In-Air Prediction", 0, 1000, 100, true, "%"),
    predict_walking = ui.new_slider("LUA", "B", "\a9f9f9f75Walking Prediction", 0, 1000, 100, true, "%"),
    predict_slowwalk = ui.new_slider("LUA", "B", "\a9f9f9f75Slow Walk Prediction", 0, 1000, 100, true, "%"),
    ui_smart_yaw_correction = ui.new_checkbox("LUA", "B", "\aD0B0FFFFCorrection \a90909025«\affef00FF⁂\a90909025»"),
    desync_detection = ui.new_checkbox("LUA", "B", "\ac7d667FF⛕ Desync Detection"),
    headshot_priority = ui.new_checkbox("LUA", "B", "\a67d77cFF Headshot Priority \a90909025«\affef00FF⁎\a90909025»"),
    head_height_adjust = ui.new_slider("LUA", "B", "\a909090FFHead Height Adjust\a909090FF", 0, 100, 50, true, "u"),
    defensive_resolver = ui.new_checkbox("LUA", "B", "\a67d77cFF Air Defensive Type Logic \a90909025«\affef00FF⁎\a90909025»", false),
    smart_head_aim = ui.new_checkbox("LUA", "B", "\a67d77cFF Smart \aD3D3D3FFHead Aim \a90909025«\affef00FF⁑\a90909025»"),
    smart_head_hp_threshold = ui.new_slider("LUA", "B", "\a909090FFPlayer HP Threshold \a909090FFfor Head Aim", 0, 100, 20, true, "HP"),
    smart_body_aim = ui.new_checkbox("LUA", "B", "\a67d77cFF Smart \aD3D3D3FFBody Aim"),
    smart_body_lethal = ui.new_checkbox("LUA", "B", "\a909090FF Force Body Aim if Lethal"),
    smart_body_hp_threshold = ui.new_slider("LUA", "B", "\a909090FFEnemy HP Threshold for Body Aim\a909090FF", 0, 100, 50, true, "HP"),
    t3mp3st_mode = ui.new_checkbox("LUA", "B", "\a80CFFFFF-- ⚡ [Features] ⚡ --\aFFFFFFFF", true),
    enhanced_defensive_fix = ui.new_checkbox("LUA", "B", "\a67d77cFF Enhanced Defensive Fix\a67d77cFF \a90909025«\affef00FF⁎\a90909025»"),
    alternative_jitter = ui.new_checkbox("LUA", "B", "\aD0B0FFFF Alternative \aD3D3D3FFDetect Jitter"),
    resolver_correction = ui.new_checkbox("LUA", "B", "\ac7d667FF Resolver Correction\ac7d667FF"),
    resolver_correction_intensity = ui.new_slider("LUA", "B", "\a5b5b5bFFResolver Correction Intensity\a5b5b5bFF", 0, 1000, 750, true, "%"),
    mode_select = ui.new_combobox("LUA", "B", "\a5b5b5bFFSelect Mode\a5b5b5bFF", { "\a67d77cFFLow Ping\a67d77cFF", "\ad66767FFHigh Ping\ad66767FF", "\ac7d667FFBalanced\ac7d667FF" }),
    flick_detection = ui.new_checkbox("LUA", "B", "\aD0B0FFFF Flick Detection\aFFFFFFFF \a90909025«\affef00FF⁎\a90909025»"),
    flick_velocity_threshold = ui.new_slider("LUA", "B", "\a5b5b5bFFFlick Velocity Threshold\a5b5b5bFF", 300, 1000, 500, true, "°/s"),
    flick_reaction_time = ui.new_slider("LUA", "B", "\a5b5b5bFFFlick Reaction Time\a5b5b5bFF", 50, 500, 200, true, "ms"),
    flick_prediction_boost = ui.new_slider("LUA", "B", "\a5b5b5bFFFlick Prediction Boost\a5b5b5bFF", 50, 1000, 500, true, "%"),
    flick_yaw_correction = ui.new_slider("LUA", "B", "\a5b5b5bFFFlick Yaw Correction\a5b5b5bFF", 0, 100, 50, true, "°"),
    flick_mode = ui.new_combobox("LUA", "B", "Flick Mode", { "Fake Flicks", "Defensive Flicks" }),
    fuck = ui.new_label("PLAYERS", "Adjustments", "\a90909055════════════════════════════════"),
    dynamic_hit_chance_label = ui.new_label("PLAYERS", "Adjustments", "\aB0B0FFFFDynamic\aFFFFFFFF minimum hit chance:"),
    confidence_threshold = ui.new_slider("PLAYERS", "Adjustments", "\a909090FFConfidence Threshold for Shooting\a909090FF", 0, 100, 50, true, "%"),
    low_confidence_delay_label = ui.new_label("PLAYERS", "Adjustments", "\aB0B0FFFFDynamic\aFFFFFFFF shot delay:"),
    low_confidence_delay = ui.new_slider("PLAYERS", "Adjustments", "\a909090FFDelay on Low Confidence\a909090FF", 0, 500, 0, true, "ms"),
    fuck_two = ui.new_label("PLAYERS", "Adjustments", "\a90909055════════════════════════════════"),
    experimental_mode = ui.new_checkbox("LUA", "B", "\aFF0000FF-- [EXPERIMENTAL MODE] --\aFFFFFFFF", true),
    experimental_mode_two = ui.new_label("LUA", "B", "\aFF0000FF-- ExpERImENtAL --\aFFFFFFFF"),
    dt_peek_fix = ui.new_checkbox("LUA", "B", "\a67d77cFFDefensive \a67d77cFFFix\a67d77cFF"),
    fakelag_optimization = ui.new_checkbox("LUA", "B", "\ac7d667FFFakelag Optimization\ac7d667FF"),
    dormant_aimbot = ui.new_checkbox("LUA", "B", "\ac7d667FFDormant Aimbot Mode\ac7d667FF"),
    dormant_min_damage = ui.new_slider("LUA", "B", "\a5b5b5bFFDormant Minimum Damage\a5b5b5bFF", 0, 100, 50, true, "damage"),
    jump_scout_opt = ui.new_checkbox("LUA", "B", "\ac7d667FFJump Scout Optimization\ac7d667FF"),
    unsafe_crage_air = ui.new_checkbox("LUA", "B", "\ad66767FFUnsafe Chrage in Air\aD3D3D3FF"),
    experimental_mode_two_1 = ui.new_label("LUA", "B", "\aFF0000FF-- devS --\aFFFFFFFF"),
    velocity_scale = ui.new_slider("LUA", "B", "\ad66767FFVelocity Scale\ad66767FF", 0, 100, 50, true, "%"),
    gravity_factor = ui.new_slider("LUA", "B", "\ad66767FFGravity Factor\ad66767FF", 0, 100, 50, true, "%")
}
 -- local imp_exp_1 = ui.new_label("CONFIG", "Presets", "\a909090FF ---------------- P R E S E T S ----------------")
local config_menu = {
    import = ui.new_button("CONFIG", "Presets", "\a909090FF Import Config ", function() end),
    export = ui.new_button("CONFIG", "Presets", "\a909090FF Export Config ", function() end)
}
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
ui.new_button("PLAYERS", "Adjustments", "\a909090FF Clear Resolver Memory ", function()
    -- Clear hit and miss logs
    hit = {}
    missed = {}

    -- Reset resolver data with weak tables
    resolver.player_data = setmetatable({}, { __mode = "v" })
    resolver.miss_memory = setmetatable({}, { __mode = "kv" })
    resolver.last_shot_id = {}
    resolver.target_player = nil
    resolver.aa_memory = setmetatable({}, { __mode = "kv" })
    resolver.anim_cache = setmetatable({}, { __mode = "k" })
    resolver.stats = {
        total_hits = 0,
        total_misses = 0,
        hits_by_method = {},
        misses_by_method = {},
        misses_by_reason = {
            spread = 0,
            prediction = 0,
            lagcomp = 0,
            defensive_low_delta = 0,
            defensive_jitter = 0,
            defensive_spin = 0,
            defensive_lc_break = 0,
            defensive_other = 0,
            resolver = 0,
            connection = 0,
            unregister_shot = 0
        }
    }
    resolver_stats.total_hits = 0
    resolver_stats.total_misses = 0
    adaptive_resolver.hit_memory = {}
    adaptive_resolver.players = {}
    adaptive_resolver.miss_memory = {}
    resolver_data = {}

    -- Reset player list settings for all enemies
    for _, player in ipairs(entity.get_players(true)) do
        plist.set(player, "Force body yaw", false)
        plist.set(player, "Override preferred hitbox", nil)
    end

    -- Log success message
    client.color_log(255, 255, 255, "[SHIT] All resolver memory and player data cleared successfully")
end)
local texts = {
    "say  ",
    "say  "
}
math.randomseed(math.floor(globals.realtime() * 1000))
local random_text = texts[math.random(1, #texts)]
client.exec(random_text)
local v0={"✞ ALARAKS DEATH FLEET ZERSTORT DEINE WELT ✞","⚡ SHIT IS A GREATEST RESOLVER ⚡","Kiss me 1 m𝘰re time, Utena <3","Это искусство🌸 [ステッカー] by AlaraK","ХАХАХАХА аларак недавно угнал инвалидную коляску","Щя пенить буш","Съешь мой конфиг, лох >:D","Щя пенить буш","фу бездарь иди купи мой фембой кфг 11","Бест ресольвер загружаеться","ты не замечаешь тех, кто реально выделяется [AlaraK]"," "," "," "," ","https://discord.gg/44Uv7YKYbk","(◣_◢) ☨ MEMPHIS GOD IS HERE ☨ (◣_◢)","ДОМИНИРУЙ КАК RuFF [SC2]","UNBELIV PIDORAS","(◣_◢) ☨ ez 1 owned by hvh boss with gamesense(alaraK) ☨ (◣_◢)","ALARAK TO BÓG HVH, SPIERDALAJ, FRAJER!","И мы курим этот splash, через суку будто dash","hardjump??","Не нужна команда, я enjoyer solo kills"};
local timer, display_time, is_displaying, random_text = 0, 2, false, ""
math.randomseed(math.floor(globals.realtime() * 1000))
random_text = texts[math.random(1, #texts)]
local motion = { base_speed = 6, _list = {} }
motion.new = function(name, new_value, speed, init)
    speed = speed or motion.base_speed
    motion._list[name] = motion._list[name] or (init or 0)
    motion._list[name] = math.lerp(motion._list[name], new_value, speed)
    return motion._list[name]
end
local file_texture = readfile("SHIT LUA PNG SUUKAAAAQA")
local meowhook, meowhook_s
if file_texture then
    meowhook = renderer.load_png(file_texture, 1024, 1024)
    meowhook_s = renderer.load_png(file_texture, 64, 64)
else
    client.color_log(255, 0, 0, "Ошибка: ЕБАНАЯ ПАСТА ВЫЕБАНА В ОЧЕЛО")
    return
end
client.set_event_callback("paint", function()

    local screen_width, screen_height = client.screen_size()

    local rectangle_alpha = motion.new("alpha_value", is_displaying and 255 or 0, 10)
    local text_alpha = motion.new("text_alpha", is_displaying and 255 or 0, 10)
    local texture_alpha = motion.new("texture_alpha", is_displaying and 255 or 0, 5)

    renderer.rectangle(0, 0, screen_width, screen_height, 0, 0, 0, rectangle_alpha)

    if meowhook then
        local texture_width, texture_height = 670, 490
        renderer.texture(meowhook, (screen_width - texture_width) / 2, (screen_height - texture_height) / 2, texture_width, texture_height, 191, 255, 255, texture_alpha, "f")
    end

    local text_width, text_height = renderer.measure_text(verdana, random_text)
    renderer.text((screen_width - text_width) / 2, (screen_height + text_height) / 2, 255, 255, 255, text_alpha, "", 0, random_text)

    if is_displaying and (globals.realtime() - timer > display_time) then
        is_displaying = false
    elseif not is_displaying and timer == 0 then
        timer, is_displaying = globals.realtime(), true
    end
end)

--[[
PIDOR
]]--

local function toggle_console(times, delay_ms)
    if times > 0 then
        client.exec("toggleconsole")
        client.delay_call(delay_ms / 1000, function()
            toggle_console(times - 1, delay_ms)
        end)
    end
end

client.exec("con_enable 1")
toggle_console(7, 766)
client.exec("clear")

client.color_log(255, 255, 255, "--------------------[WELCOME]---------------------")
client.color_log(255, 255, 255, "    ")
client.color_log(255, 255, 255, "Welcome to SHIT!")
client.color_log(255, 255, 255, "NOT In resolver will be some new functions")
client.color_log(255, 255, 255, "NOT Version - 1.0.0 [PRE-RELEASE]")
client.color_log(255, 255, 255, "   ")
client.color_log(255, 255, 255, "--------------------[CONTACTS]--------------------")
client.color_log(255, 255, 255, "   ")
client.color_log(255, 255, 255, "Discord - unfallxd")
client.color_log(255, 255, 255, "Telegram - nema")
client.color_log(255, 255, 255, "   ")
client.color_log(255, 255, 255, "--------------------[LAST IMPROVES]--------------------")
client.color_log(255, 255, 255, "   ")
client.color_log(255, 255, 255, "NOT Improved adaptive prediction, anti-aim correction")
client.color_log(255, 255, 255, "   ")
client.color_log(255, 255, 255, "NOT Optimized low/high ping, fakelag compensation")
client.color_log(255, 255, 255, "   ")
client.color_log(255, 255, 255, "--------------------[国F∆∮↓∧シ;]--------------------")
client.color_log(255, 255, 255, "   ")
client.color_log(255, 255, 255, "К5β∝ひa#字µ9Y∧文Bг≤シT$∆∮©Zx*国mП-яЭ2†v≠漢∑ц@↓π+⊂йF↑§®L~√∞=∨Д中,u.∩™⊃C;:¶€бN%⊇R&↑ひ - µB@≠∆Lц9⊂R∩йx∞Z∑†字m≥gβ&Nπ国C⊇↓5FДひa¶TЭ~®u∮=в+K§Я∝Y⊃€漢3中Ш%v.∧√;гПµひ")
client.color_log(255, 255, 255, "   ")
client.color_log(255, 255, 255, "*∮я5€Z国x∝µひцT2≠文∑B↓©K∧中a$∆⊂L9§πF.®~⊃∞yДm#†N∩⊇П,βCシv@¶≥R&字+√Э=й;∮u%гh°4i¶∝中 - †uZ⊂9Пгµ∨¶T∞Fv文LЭ&Nπx国§βДR∮C@aひ∑中=~⊇yK∆⊃Yб5€m≠й∧B⊂↓√%漢.≥¶シ©ц+™3字")
client.color_log(255, 255, 255, "   ")
client.color_log(255, 255, 255, "--------------------[CONSOLE]---------------------")
client.color_log(255, 255, 255, "   ")
client.color_log(255, 255, 255, "[SHIT Logs] Pre-release: may be bugs")
client.color_log(255, 255, 255, "   ")

ui.new_label("LUA", "B", "                                        ")

local local_player = entity.get_local_player()
local player_name = local_player and entity.get_player_name(local_player) or "Tal'darim'4ick"
ui.new_label("LUA", "B", "Welcome, \a778899FF" .. player_name .. "!!")
ui.new_label("LUA", "B", "                                 ")
local enemy_data = {}

local function detect_yaw_jitter(yaw_history)
    if #yaw_history < 5 then
        return "No"
    end

    local jitter_count = 0
    local max_jitter = 0

    for i = 5, #yaw_history do
        local prev_diff = yaw_history[i - 2] - yaw_history[i - 3]
        local curr_diff = yaw_history[i] - yaw_history[i - 1]

        if prev_diff * curr_diff < -180 and math.abs(curr_diff) > 2 then
            jitter_count = jitter_count + 1
            max_jitter = math.max(max_jitter, math.abs(curr_diff))
        end
    end

    return jitter_count >= 2 and "Yes (" .. math.floor(max_jitter) .. "°)" or "No"
end

local function detect_yaw_flick(yaw_history)
    if #yaw_history < 2 then
        return "No"
    end

    for i = 2, #yaw_history do
        local diff = math.abs(yaw_history[i] - yaw_history[i - 1])
        if diff > 90 then
            return "Yes (" .. math.floor(diff) .. "°)"
        end
    end

    return "No"
end

local function detect_static_position(pos_history, yaw_history)
    if #pos_history < 2 or #yaw_history < 2 then
        return "No"
    end

    local last_index = #pos_history
    local min_x, max_x = pos_history[last_index].x, pos_history[last_index].x
    local min_y, max_y = pos_history[last_index].y, pos_history[last_index].y
    local min_z, max_z = pos_history[last_index].z, pos_history[last_index].z
    local min_yaw, max_yaw = yaw_history[last_index], yaw_history[last_index]

    for i = last_index + 1, #pos_history do
        min_x, max_x = math.min(min_x, pos_history[i].x), math.max(max_x, pos_history[i].x)
        min_y, max_y = math.min(min_y, pos_history[i].y), math.max(max_y, pos_history[i].y)
        min_z, max_z = math.min(min_z, pos_history[i].z), math.max(max_z, pos_history[i].z)
        min_yaw, max_yaw = math.min(min_yaw, yaw_history[i]), math.max(max_yaw, yaw_history[i])
    end

    local max_pos_diff = math.max(max_x - min_x, max_y - min_y, max_z - min_z)
    local yaw_diff = math.abs(max_yaw - min_yaw)

    return max_pos_diff < 2 and yaw_diff < 1 and "Yes" or "No"
end

local function detect_fakelag(simtime_history)
    if #simtime_history < 2 then
        return "No"
    end

    local time_diff = simtime_history[#simtime_history] - simtime_history[#simtime_history - 1]
    local tick_interval = globals.tickinterval()
    local choke_ticks = math.floor(time_diff / tick_interval) - 1

    return choke_ticks > 8 and "Yes (" .. choke_ticks .. " ticks)" or "No"
end

local function detect_afk(pos_history, yaw_history, cmd_history)
    if #pos_history < 2 or #yaw_history < 2 or #cmd_history < 200 then
        return "No"
    end

    local last_index = #pos_history
    local min_x, max_x = pos_history[last_index].x, pos_history[last_index].x
    local min_y, max_y = pos_history[last_index].y, pos_history[last_index].y
    local min_z, max_z = pos_history[last_index].z, pos_history[last_index].z
    local min_yaw, max_yaw = yaw_history[last_index], yaw_history[last_index]
    local total_cmd = 0

    for i = last_index + 1, #pos_history do
        min_x, max_x = math.min(min_x, pos_history[i].x), math.max(max_x, pos_history[i].x)
        min_y, max_y = math.min(min_y, pos_history[i].y), math.max(max_y, pos_history[i].y)
        min_z, max_z = math.min(min_z, pos_history[i].z), math.max(max_z, pos_history[i].z)
        min_yaw, max_yaw = math.min(min_yaw, yaw_history[i]), math.max(max_yaw, yaw_history[i])
        total_cmd = total_cmd + cmd_history[i]
    end

    local max_pos_diff = math.max(max_x - min_x, max_y - min_y, max_z - min_z)
    local yaw_diff = math.abs(max_yaw - min_yaw)
    local avg_cmd_per_tick = total_cmd / 256

    return max_pos_diff < 0.5 and yaw_diff < 0.5 and avg_cmd_per_tick < 50 and "Yes" or "No"
end

local function update_choke_history(player_id, choke_ticks)
    local player_data = resolver_data[player_id] or {}
    player_data.choke_history = player_data.choke_history or {}

    table.insert(player_data.choke_history, choke_ticks)
    if #player_data.choke_history > 28 then
        table.remove(player_data.choke_history, 1)
    end

    resolver_data[player_id] = player_data
    return player_data.choke_history
end

local function calculate_adaptive_choke(player_id)
    local choke_history = update_choke_history(player_id, get_choke(player_id))

    if #choke_history < 4 then
        return choke_history[#choke_history] or 1
    end

    local sum_choke = 0
    for _, choke in ipairs(choke_history) do
        sum_choke = sum_choke + choke
    end

    local mean_choke = sum_choke / #choke_history
    local std_dev_choke = calculate_std_dev(choke_history)

    return math.clamp(mean_choke + std_dev_choke, 1, 15)
end

local function update_enemy_data()
    local enemies = entity.get_players(true)
    for _, enemy in ipairs(enemies) do
        if not entity.is_alive(enemy) then
            enemy_data[enemy] = nil
            goto continue
        end

        enemy_data[enemy] = enemy_data[enemy] or {
            positions = {},
            yaws = {},
            pitches = {},
            velocities = {},
            sim_times = {},
            sim_time_history = {}
        }

        local data = enemy_data[enemy]
        local x, y, z = entity.get_prop(enemy, "m_vecOrigin")
        if x then
            table.insert(data.positions, {x = x, y = y, z = z})

            local pitch, yaw = entity.get_prop(enemy, "m_angEyeAngles")
            table.insert(data.pitches, pitch or 0)
            table.insert(data.yaws, yaw or 0)

            local vx = entity.get_prop(enemy, "m_vecVelocity[0]") or 0
            local vy = entity.get_prop(enemy, "m_vecVelocity[1]") or 0
            local vz = entity.get_prop(enemy, "m_vecVelocity[2]") or 0
            local velocity = math.sqrt(vx^2 + vy^2 + vz^2)
            table.insert(data.velocities, velocity)

            local sim_time = entity.get_prop(enemy, "m_flSimulationTime") or 0
            table.insert(data.sim_times, sim_time)
            table.insert(data.sim_time_history, sim_time)

            if #data.positions > 30 then
                table.remove(data.positions, 1)
                table.remove(data.yaws, 1)
                table.remove(data.pitches, 1)
                table.remove(data.velocities, 1)
                table.remove(data.sim_times, 1)
            end

            if #data.sim_time_history > 28 then
                table.remove(data.sim_time_history, 1)
            end
        end

        ::continue::
    end
end

client.set_event_callback("player_connect_full", function(event)
    local player = client.userid_to_entindex(event.userid)
    if player == entity.get_local_player() then
        enemy_data = {}
    end
end)

client.set_event_callback("player_death", function(event)
    local player = client.userid_to_entindex(event.userid)
    if enemy_data[player] then
        enemy_data[player] = nil
    end
end)

--
--[[
 .
]]--
local smileys = {
    "•̀ ω •́",
    "(＠＾０＾)",
    "＾-＾",
    "(^_^)",
    "(*^_^*)",
    "＾-＾",
    ";P",
    "^3^",
    "(✿◠‿◠)",
    "(✿◡‿◡)",
    "（⊙ｏ⊙）",
    "(‾◡◝)",
    "(◕‿◕)"
}
local sad_smileys = {
    "•̀ ω •́",
    "(＠＾０＾)",
    "＾-＾",
    "(^_^)",
    "(*^_^*)",
    "＾-＾",
    ";P",
    "^3^",
    "(✿◠‿◠)",
    "(✿◡‿◡)",
    "（⊙ｏ⊙）",
    "(‾◡◝)",
    "(◕‿◕)"
}
local function init_random_seed()
    local success, result = pcall(function() return os.time() end)
    if success and result then
        math.randomseed(result)
    else
        math.randomseed(client.unix_time()) 
    end
end
init_random_seed()

local function display_ui_advertisement()
    local random_smiley = smileys[math.random(1, #smileys)]
    local random_sad_smiley = sad_smileys[math.random(1, #sad_smileys)]

    ui.new_label("LUA", "B", "⌚ Sub expiration:\a90EE90FF Never \a90909040" .. random_smiley)
    ui.new_label("LUA", "B", "                                        ")
    ui.new_label("LUA", "B", "⚙ Version:\a90EE90FF Pre-release \a90909040" .. random_smiley)
    ui.new_label("LUA", "B", "                                        ")
    ui.new_label("LUA", "B", "✨ Coder:\aDC143CFF AlaraK\aD3D3D3FF; \aDC143CFFАгент \a90909040" .. random_smiley)
    ui.new_label("LUA", "B", "                                        ")
    ui.new_label("LUA", "B", "❗ Support:\aDC143CFF Агент \a90909040" .. random_sad_smiley)

    ui.new_button("LUA", "B", "\a909090FF☆꧁✬◦°˚°◦. Discord .◦°˚°◦✬꧂☆\a909090FF", function()
        client.exec("УБЫРЬ ЭТОЙ ЛУА: https://discord.gg/gNbZAhKnJj")
        client.color_log(255, 255, 255, "ЕБЫРЬ ЛУА: Join us: https://discord.gg/gNbZAhKnJj!")
    end)
end

display_ui_advertisement()
local smileys = {
    "Ютуб2017 - LilSemmi",
    "HMU - Tobias Dray ",
    "707 - Ftlframe",
    "edgy - luvwillow",
    "OG - LeLxx",
    "vortex - isq",
    "DINNER! - femtanyl",
    "Heaven's Devils  - Animelmack",
    "40 DAYS - GREEN ORXNGE",
    "Хаги Ваги - kyz9ka",
    "JUMPSTYLE PARTY - RomancePlanet",
    "Австралия - МАЙАМИ",
    "Terran 2 - DSC",
    "Jump - Slowed - ecZk",
    "Культурный кот - Нежное Это",
    ".50AE - ZWE1HVNDXR",
    "Smoke out - oppslll",
    "Failed to connect spotify. Err code: *null*",
    "Failed to connect spotify. Err code: X41822N",
    "None"
}
local function init_random_seed()
    math.randomseed(client.unix_time())
end
init_random_seed()
local function set_random_labels()
    local version_smiley = smileys[math.random(1, #smileys)]
    ui.new_label("LUA", "B", "\a90909040♪ Song of the day: " .. version_smiley) -- пиздите
end
set_random_labels()

local function hsv_to_rgb(hue, saturation, value)
    local hue_index = math.floor(hue * 6)
    local fraction = (hue * 6) - hue_index
    local p = value * (1 - saturation)
    local q = value * (1 - fraction * saturation)
    local t = value * (1 - (1 - fraction) * saturation)

    hue_index = hue_index % 6
    if hue_index == 0 then
        return math.floor(value * 255), math.floor(t * 255), math.floor(p * 255)
    elseif hue_index == 1 then
        return math.floor(q * 255), math.floor(value * 255), math.floor(p * 255)
    elseif hue_index == 2 then
        return math.floor(p * 255), math.floor(value * 255), math.floor(t * 255)
    elseif hue_index == 3 then
        return math.floor(p * 255), math.floor(q * 255), math.floor(value * 255)
    elseif hue_index == 4 then
        return math.floor(t * 255), math.floor(p * 255), math.floor(value * 255)
    elseif hue_index == 5 then
        return math.floor(value * 255), math.floor(p * 255), math.floor(q * 255)
    end
end

local my_label = ui.new_label("CONFIG", "Presets", "Last update: ??.??.??")
local speed = 1 
local color1 = {255, 0, 255}
local color2 = {0, 128, 255} 
local function lerp(a, b, t)
    return a + (b - a) * t
end
local function getGradientColor(x, width)
    local time = globals.realtime() * speed
    local offset = (time % 2) / 2  -- 0 to 1 цикл
    local pos = (x / width + offset) % 1

    local r = lerp(color1[1], color2[1], pos)
    local g = lerp(color1[2], color2[2], pos)
    local b = lerp(color1[3], color2[3], pos)

    return math.floor(r), math.floor(g), math.floor(b)
end
client.set_event_callback("paint_ui", function()
    local text = " Last update: 28.05.25"
    local prefix = "\aD3D3D399 Last Update: " 
    local gradient_part = "13.05.25"
    local width = 8
    local final_text = prefix
    local gradient_count = 0 

    for i = 1, #gradient_part do
        local char = gradient_part:sub(i, i) == " " and "\x20" or gradient_part:sub(i, i)
        if char:match("[%d%.]") then
           
            gradient_count = gradient_count + 1
            local r, g, b = getGradientColor(gradient_count, width)
            final_text = final_text .. string.format("\a%02X%02X%02XFF%s", r, g, b, char)
        end
    end
     -- апять
    ui.set(my_label, final_text)
end)
local start_time = client.unix_time()

local function calculate_elapsed_time()
    local elapsed_seconds = client.unix_time() - start_time
    local hours = math.floor(elapsed_seconds / 3600)
    local minutes = math.floor((elapsed_seconds - (hours * 3600)) / 60)
    local seconds = math.floor(elapsed_seconds - (hours * 3600) - (minutes * 60))
    return string.format("%02d:%02d:%02d", hours, minutes, seconds)
end

local function lerp(a, b, t)
    return a + (b - a) * t
end

local function compute_gradient_color(position, length)
    local time = globals.realtime() * speed
    local phase = (time % 2) / 2
    local t = (position / length) + phase
    local t_wrapped = t % 1
    local r = lerp(color1[1], color2[1], t_wrapped)
    local g = lerp(color1[2], color2[2], t_wrapped)
    local b = lerp(color1[3], color2[3], t_wrapped)
    return math.floor(r), math.floor(g), math.floor(b)
end

local tab, container = "CONFIG", "Presets"
local session_label = ui.new_label(tab, container, "Your Session Time: FUCK LUA")
local spacer_label = ui.new_label("LUA", "B", "   ")

client.set_event_callback("paint_ui", function()
    if not ui.is_menu_open() then
        ui.set(session_label, "Your Session Time: FUCK LUA")
        return
    end

    local time_str = calculate_elapsed_time()
    local str_length = #time_str
    local colored_str = "\aD3D3D399 Your Session Time: FUCK LUA "

    for i = 1, str_length do
        local char = time_str:sub(i, i)
        if char == " " then
            char = "\x20"
        end
        local r, g, b = compute_gradient_color(i, str_length)
        colored_str = colored_str .. string.format("\a%02X%02X%02XFF%s", r, g, b, char)
    end

    ui.set(session_label, colored_str)
end)

local function table_contains(tab, val)
    if type(tab) ~= "table" then return false end
    for _, value in ipairs(tab) do
        if value == val then return true end
    end
    return false
end

local default_elements = {
    ui_elements.prediction_factor,
    ui_elements.fast_mode,
    ui_elements.trashtalk_enabled,
    ui_elements.smart_head_aim,
    ui_elements.smart_head_hp_threshold
}

local aggressive_elements = {
    ui_elements.prediction_factor,
    ui_elements.fast_mode,
    ui_elements.headshot_priority,
    ui_elements.head_height_adjust,
    ui_elements.flick_prediction_boost,
    ui_elements.confidence_threshold,
    ui_elements.enhanced_defensive_fix,
    ui_elements.low_confidence_delay,
    ui_elements.resolver_correction,
    ui_elements.resolver_correction_intensity,
    ui_elements.mode_select
}

local adaptive_elements = {
    ui_elements.tst_prediction_factor,
    ui_elements.prediction_factor,
    ui_elements.fast_mode,
    ui_elements.flick_prediction_boost,
    ui_elements.resolver_correction_intensity,
    ui_elements.mode_select
}

local conditional_elements = {
    [ui_elements.tst_prediction_factor] = { ui_elements.prediction_factor },
    [ui_elements.manual_predict] = {
        ui_elements.manual_states,
        ui_elements.predict_standing,
        ui_elements.predict_crouching,
        ui_elements.predict_air,
        ui_elements.predict_walking,
        ui_elements.predict_slowwalk
    },
    [ui_elements.desync_detection] = { ui_elements.desync_range },
    [ui_elements.headshot_priority] = { ui_elements.head_height_adjust },
    [ui_elements.smart_body_aim] = { ui_elements.smart_body_hp_threshold, ui_elements.smart_body_lethal },
    [ui_elements.smart_head_aim] = { ui_elements.smart_head_hp_threshold },
    [ui_elements.flick_detection] = {
        ui_elements.flick_velocity_threshold,
        ui_elements.flick_reaction_time,
        ui_elements.flick_prediction_boost,
        ui_elements.flick_yaw_correction,
        ui_elements.flick_mode
    }
}

local function update_ui_visibility()
    local resolver_enabled = ui.get(ui_resolver_enabled)
    local mode = ui.get(ui_mode_select)
    local show_settings = ui.get(ui_show_settings)

    for _, element in pairs(ui_elements) do
        if element then
            ui.set_visible(element, false)
        end
    end
    for _, group in pairs(conditional_elements) do
        for _, element in ipairs(group) do
            if element then
                ui.set_visible(element, false)
            end
        end
    end

    ui.set_visible(ui_resolver_enabled, true)
    ui.set_visible(ui_mode_select, true)
    ui.set_visible(ui_show_settings, resolver_enabled and mode ~= "Custom")
    ui.set_visible(label_original, not resolver_enabled)
    ui.set_visible(label_enabled_default, resolver_enabled and mode == "Default")
    ui.set_visible(label_enabled_custom, resolver_enabled and mode == "Custom")
    ui.set_visible(label_enabled_aggressive, resolver_enabled and mode == "Aggressive")
    ui.set_visible(label_enabled_adaptive, resolver_enabled and mode == "Adaptive")

    if not resolver_enabled then
        return
    end

    if mode == "Default" then
        ui.set(ui_elements.prediction_factor, 15)
        ui.set(ui_elements.smart_head_hp_threshold, 90)
        if show_settings then
            for _, element in ipairs(default_elements) do
                if element then
                    ui.set_visible(element, true)
                end
            end
        end
    elseif mode == "Custom" then
        for _, element in pairs(ui_elements) do
            if element and element ~= ui_elements.t3mp3st_mode and element ~= ui_elements.experimental_mode then
                ui.set_visible(element, true)
            end
        end
        ui.set_visible(ui_elements.confidence_threshold, true)
        ui.set_visible(ui_elements.low_confidence_delay_label, true)
        ui.set_visible(ui_elements.low_confidence_delay, true)
        for control, dependents in pairs(conditional_elements) do
            local is_enabled = ui.get(control)
            for _, dependent in ipairs(dependents) do
                if dependent then
                    ui.set_visible(dependent, is_enabled)
                end
            end
        end
    elseif mode == "Aggressive" then
        ui.set(ui_elements.flick_prediction_boost, 5)
        ui.set(ui_elements.confidence_threshold, 60)
        ui.set(ui_elements.fast_mode, true)
        ui.set(ui_elements.enhanced_defensive_fix, false)
        ui.set(ui_elements.prediction_factor, 25)
        ui.set(ui_elements.head_height_adjust, 50)
        ui.set(ui_elements.low_confidence_delay, 150)
        ui.set(ui_elements.headshot_priority, true)
        if show_settings then
            for _, element in ipairs(aggressive_elements) do
                if element then
                    ui.set_visible(element, true)
                end
            end
            for _, element in ipairs(aggressive_elements) do
                if element and conditional_elements[element] and ui.get(element) then
                    for _, dependent in ipairs(conditional_elements[element]) do
                        if dependent then
                            ui.set_visible(dependent, true)
                        end
                    end
                end
            end
        end
    elseif mode == "Adaptive" then
        ui.set(ui_elements.flick_prediction_boost, 2)
        ui.set(ui_elements.fast_mode, true)
        ui.set(ui_elements.confidence_threshold, 80)
        ui.set(ui_elements.low_confidence_delay, 100)
        ui.set(ui_elements.tst_prediction_factor, true)
        ui.set(ui_elements.prediction_factor, 20)
        if show_settings then
            for _, element in ipairs(adaptive_elements) do
                if element then
                    ui.set_visible(element, true)
                end
            end
            for _, element in ipairs(adaptive_elements) do
                if element and conditional_elements[element] and ui.get(element) then
                    for _, dependent in ipairs(conditional_elements[element]) do
                        if dependent then
                            ui.set_visible(dependent, true)
                        end
                    end
                end
            end
        end
    end
end

ui.set_callback(ui_resolver_enabled, update_ui_visibility)
ui.set_callback(ui_mode_select, update_ui_visibility)
ui.set_callback(ui_show_settings, update_ui_visibility)

for control, _ in pairs(conditional_elements) do
    ui.set_callback(control, function()
        if ui.get(ui_mode_select) == "Custom" then
            local is_enabled = ui.get(control)
            for _, dependent in ipairs(conditional_elements[control]) do
                if dependent then
                    ui.set_visible(dependent, is_enabled)
                end
            end
        end
    end)
end

client.delay_call(0.1, update_ui_visibility)

client.set_event_callback("paint", function()
    local resolver_enabled = ui.get(ui_resolver_enabled)
    local cl_drawhud_enabled = client.get_cvar("cl_drawhud") == "1"

    if not cl_drawhud_enabled then
        client.color_log(255, 255, 255, "[SHIT] Warning: cl_drawhud is disabled, indicators will not be visible!")
    end

    if resolver_enabled then
        renderer.indicator(255, 255, 255, "⚡ SHIT FUCKED BY UNFALL ⚡")
    end
end)

local function get_bullet_speed(weapon_id) return 2500 end
local function get_weapon_damage(weapon_id) return 30 end
local function lerp(a, b, t) return a + (b - a) * t end
local function get_player_state(enemy)
    local vz = entity.get_prop(enemy, "m_vecVelocity[2]") or 0
    local speed = math.sqrt((entity.get_prop(enemy, "m_vecVelocity[0]") or 0)^2 + (entity.get_prop(enemy, "m_vecVelocity[1]") or 0)^2)
    if vz ~= 0 then return "in_air" end
    if speed < 10 then return "standing" end
    if speed < 50 then return "slow_walk" end
    return "walking"
end
local function detect_jitter_pattern(history) return #history > 2 and math_util.angle_diff(history[#history-1], history[#history]) > 40 end
local function detect_desync_pattern(history) return 0 end
local function get_lower_body_yaw(enemy) return entity.get_prop(enemy, "m_flLowerBodyYawTarget") or 0 end
local function get_real_yaw_from_animations(enemy) return entity.get_prop(enemy, "m_angEyeAngles[1]") or 0 end
local function get_animation_state(enemy) return "standing" end
local function detect_fakelag(enemy) return false end
local function trace_to_lby(enemy, lby) return false end
local function should_use_lby(enemy, lby, eye_yaw, state, last_update) return false end
local function is_shooting(enemy) return false end
local function is_player_jumping(enemy) return (entity.get_prop(enemy, "m_vecVelocity[2]") or 0) ~= 0 end
local function std_dev(t) return 0 end
local function enhanced_defensive_fix(enemy, yaw) return yaw end
local function flick_compensation(enemy, yaw) return yaw end
local function compensate_spread(weapon_id, state, x, y, z, distance) return x, y, z end
local function is_fast_firing_weapon(weapon_id) return false end
-- нуну
local function UpdateEnemyData(entity_id)

    resolver_data[entity_id] = resolver_data[entity_id] or {
        yaw_history = {},
        lby_history = {},
        eye_angles_history = {},
        miss_count = 0, 
        hit_count = 0, 
        confidence = 0, 
        last_yaw = 0, 
        last_seen = globals.realtime()
    }

    local data = resolver_data[entity_id]

    local eye_pitch = entity.get_prop(entity_id, "m_angEyeAngles[1]") or 0

    table.insert(data.eye_angles_history, { y = eye_pitch })

    if #data.eye_angles_history > RESOLVER_CONST.MAX_HISTORY_SIZE then
        table.remove(data.eye_angles_history, 1)
    end

    data.last_seen = globals.realtime()
    return true
end

local function HandleEntities()

end

local function PredictEntityPosition(entity_id, time)

    local origin_x = entity.get_prop(entity_id, "m_vecOrigin[0]") or 0
    local origin_y = entity.get_prop(entity_id, "m_vecOrigin[1]") or 0
    local origin_z = entity.get_prop(entity_id, "m_vecOrigin[2]") or 0

    local velocity_x = entity.get_prop(entity_id, "m_vecVelocity[0]") or 0
    local velocity_y = entity.get_prop(entity_id, "m_vecVelocity[1]") or 0
    local velocity_z = entity.get_prop(entity_id, "m_vecVelocity[2]") or 0

    return {
        x = origin_x + (velocity_x * time),
        y = origin_y + (velocity_y * time),
        z = origin_z + (velocity_z * time)
    }
end

local function DetectJitterPattern(entity_id, resolver_data)
    local yaw_history = resolver_data.yaw_history
    if not yaw_history or #yaw_history < 3 then
        return "unknown", 0
    end

    local pattern = "unknown"
    local max_delta = 0
    local pose_history = resolver_data.pose_history or {}
    local deltas = {}

    local pose_param = entity.get_prop(entity_id, "m_flPoseParameter", 11) or 0
    local body_yaw = (pose_param * 120) - 60
    table.insert(pose_history, body_yaw)
    if #pose_history > 5 then
        table.remove(pose_history, 1)
    end
    resolver_data.pose_history = pose_history

    local delta_count = 0
    for i = 2, #yaw_history - 1 do
        local yaw_diff = math_util.angle_diff(yaw_history[i], yaw_history[i + 1])
        local pose_diff = (i <= #pose_history - 1) and math.abs(math_util.angle_diff(pose_history[i], pose_history[i + 1])) or 0
        if yaw_diff > RESOLVER_CONST.JITTER_DETECTION_THRESHOLD and pose_diff < 1 then
            delta_count = delta_count + 1
            max_delta = math.max(max_delta, yaw_diff)
        end
    end

    if delta_count >= 2 then
        pattern = "random"
    elseif delta_count == 1 then
        pattern = "switch"
    elseif delta_count == 0 then
        pattern = "static"
    end

    if pattern == "random" then
        max_delta = math.min(max_delta * 0.5, RESOLVER_CONST.MAX_DESYNC_DELTA)
    elseif pattern == "switch" then
        max_delta = math.min(max_delta, RESOLVER_CONST.MAX_DESYNC_DELTA)
    else
        max_delta = math.min(max_delta * 0.8, RESOLVER_CONST.MAX_DESYNC_DELTA)
    end

    return pattern, max_delta
end

local function ApplySmartYawCorrection(entity_id, current_yaw, resolver_data, yaw_diff, is_fakelag, is_jitter)
    if not ui.get(ui_elements.ui_smart_yaw_correction) then
        return current_yaw
    end

    local latency = client.latency()
    local tick_interval = globals.tickinterval()
    local player_state = get_player_state(entity_id)
    local anim_state = get_animation_state(entity_id)
    local fakelag_detected = detect_fakelag(entity_id)
    local lby_stability = std_dev(resolver_data.lby_history)
    local yaw_threshold = ui.get(ui_elements.yaw_diff_threshold) or 10
    local desync_range = ui.get(ui_elements.desync_range) or 60
    local auto_switch = ui.get(ui_elements.adaptive_auto_switch)
    local desync_side = resolver_data.desync_side or 0
    local adjusted_desync_range = desync_range

    if auto_switch then
        desync_side, adjusted_desync_range = detect_desync_pattern(resolver_data.yaw_history, resolver_data.lby_history)
        resolver_data.desync_side = desync_side
        resolver_data.desync_range = adjusted_desync_range
        if desync_side ~= 0 then
            desync_range = adjusted_desync_range
            log_debug(string.format("Auto desync detection for %s: side=%d, range=%.1f", entity.get_player_name(entity_id), desync_side, desync_range))
        end
    end

    if latency > 0.2 then
        yaw_threshold = yaw_threshold * 1.2
    elseif latency < 0.05 then
        yaw_threshold = yaw_threshold * 0.8
    end
    if is_jitter then
        yaw_threshold = yaw_threshold * 0.7
    end
    if player_state == "standing" and not fakelag_detected then
        yaw_threshold = yaw_threshold * 0.9
    elseif player_state == "in_air" then
        yaw_threshold = yaw_threshold * 1.2
    elseif player_state == "crouching" then
        yaw_threshold = yaw_threshold * 0.95
    end
    yaw_threshold = math.clamp(yaw_threshold, 5, 30)

    if fakelag_detected then
        desync_range = desync_range * 1.5
    elseif is_jitter then
        desync_range = desync_range * 0.8
    end
    if resolver_data.miss_count > 3 then
        desync_range = desync_range * (1 + resolver_data.miss_count * 0.1)
    end
    if player_state == "crouching" then
        desync_range = desync_range * 0.9
    elseif player_state == "running" then
        desync_range = desync_range * 1.2
    end
    desync_range = math.clamp(desync_range, DESYNC_CONST.MIN_DESYNC_RANGE, DESYNC_CONST.MAX_DESYNC_DELTA)

    local intensity = 1
    if latency > 0.3 then
        intensity = intensity * 0.8
    elseif latency < 0.1 then
        intensity = intensity * 1.2
    end
    if anim_state == "crouching" then
        intensity = intensity * 0.9
    elseif anim_state == "running" then
        intensity = intensity * 0.95
    end

    if is_jitter and ui.get(ui_elements.jitter_detection) then
        local jitter_yaw = ui.get(ui_elements.jitter_yaw_adjust)
        intensity = intensity * 0.9
        local yaw_adjust = jitter_yaw * ((desync_side > 0 and 1) or -1)
        if not desync_side then
            yaw_adjust = math.random(-desync_range, desync_range)
        end
        resolver_data.confidence = math.max(50, resolver_data.confidence - 0.1)
        resolver_data.aa_pattern = "jitter"
        log_debug(string.format("Jitter correction for %s: yaw=%.1f, intensity=%.2f", entity.get_player_name(entity_id), yaw_adjust, intensity))
    end

    if resolver_data.flick_detected and ui.get(ui_elements.flick_detection) then
        local flick_yaw = ui.get(ui_elements.flick_yaw_correction)
        intensity = intensity * 0.8
        local yaw_adjust = flick_yaw * ((desync_side > 0 and 1) or -1)
        resolver_data.confidence = math.max(100, resolver_data.confidence - 0.2)
        resolver_data.aa_pattern = "flick"
        log_debug(string.format("Flick correction for %s: yaw=%.1f, intensity=%.2f", entity.get_player_name(entity_id), yaw_adjust, intensity))
    end

    local final_yaw = current_yaw
    if yaw_diff > yaw_threshold or desync_side ~= 0 then
        local yaw_adjust = desync_range * desync_side
        intensity = intensity * (1 + resolver_data.miss_count * 0.05)
        resolver_data.confidence = math.min(100, resolver_data.confidence + DESYNC_CONST.CONFIDENCE_BOOST * 0.5)
        final_yaw = normalize_angle(current_yaw + (yaw_adjust * intensity))
        log_debug(string.format("Desync correction for %s: yaw=%.1f, side=%d, range=%.1f, intensity=%.2f", entity.get_player_name(entity_id), final_yaw, desync_side, desync_range, intensity))
    end

    if player_state == "standing" and not fakelag_detected and lby_stability < ui.get(ui_elements.jitter_lby_threshold) then
        local lby_yaw = get_lower_body_yaw(entity_id)
        final_yaw = lby_yaw - current_yaw
        intensity = intensity * 0.8
        resolver_data.confidence = math.min(100, resolver_data.confidence + 0.1)
        log_debug(string.format("Standing LBY correction for %s: yaw=%.1f, lby_stability=%.1f, intensity=%.2f", entity.get_player_name(entity_id), final_yaw, lby_stability, intensity))
    elseif player_state == "running" then
        final_yaw = current_yaw + 5
        resolver_data.confidence = math.max(50, resolver_data.confidence - 0.1)
    elseif player_state == "crouching" then
        final_yaw = -100
        intensity = intensity * 0.9
    end

    final_yaw = math.lerp(current_yaw, normalize_angle(final_yaw), DESYNC_CONST.LERP_FACTOR)
    final_yaw = math.clamp(final_yaw, -DESYNC_CONST.MAX_DESYNC_DELTA, DESYNC_CONST.MAX_DESYNC_DELTA)

    if resolver_data.confidence < ui.get(ui_elements.confidence_threshold) and is_jitter then
        final_yaw = normalize_angle(final_yaw + math.random(-60, 60))
        log_debug(string.format("Low confidence correction for %s: random adjust, final_yaw=%.1f", entity.get_player_name(entity_id), final_yaw))
    end

    resolver_data.last_yaw = final_yaw
    resolver_data[entity_id] = resolver_data
    log_debug(string.format("Smart Yaw Correction for %s: final_yaw=%.1f, threshold=%.1f, desync_range=%.1f, confidence=%.1f", entity.get_player_name(entity_id), final_yaw, yaw_threshold, desync_range, resolver_data.confidence))

    return final_yaw
end
-- тест фейклаг
local function PredictPlayerPosition(entity_id, origin_x, origin_y, origin_z)
    local resolver_data = resolver_data[entity_id] or {}
    local is_fakelag, fakelag_mode, max_ticks, tick_multiplier = detect_fakelag(entity_id)
    
    if not is_fakelag or not resolver_data.fakelag_history or #resolver_data.fakelag_history < 3 then
        return origin_x, origin_y, origin_z
    end

    local velocity_x = entity.get_prop(entity_id, "m_vecVelocity[0]") or 0
    local velocity_y = entity.get_prop(entity_id, "m_vecVelocity[1]") or 0
    local velocity_z = entity.get_prop(entity_id, "m_vecVelocity[2]") or 0
    
    local tick_interval = globals.tickinterval()
    local latency = client.latency()
    local head_x, head_y, head_z = entity.hitbox_position(entity_id, 0)
    local distance_to_head = math.sqrt(velocity_x^2 + velocity_y^2)
    
    local clamp_range = math.clamp(distance_to_head / 10, 0, 1) + math.clamp(latency * 100, -5, 5)
    local ticks_to_predict

    if fakelag_mode == "adaptive" then
        ticks_to_predict = tick_multiplier * latency
    elseif fakelag_mode == "high" then
        ticks_to_predict = math.min(max_ticks, 10) * latency
    elseif fakelag_mode == "low" then
        ticks_to_predict = math.min(max_ticks, 5) * latency
    end

    local predicted_x = origin_x + (velocity_x * ticks_to_predict)
    local predicted_y = origin_y + (velocity_y * ticks_to_predict)
    local predicted_z = origin_z + (velocity_z * ticks_to_predict) - (400 * (ticks_to_predict^2) / 2)
    
    predicted_y = math.clamp(predicted_y, head_y - clamp_range, head_y + clamp_range)
    predicted_z = math.clamp(predicted_z, head_z - clamp_range, head_z + clamp_range)
    
    return predicted_x, predicted_y, predicted_z
end
client.set_event_callback("setup_command", n3r4z1m_resolver)
local shots = {
    hit = {},
    missed = { 0, 0, 0, 0, 0 }, -- 1 сприд, 2 пред еррор, 3 пинг (смерть), 4- хз, 5 тотально
    total = 0
}
local function lerp(a, b, t)
    return a + (b - a) * t
end
function distance3D(point1, point2)
    local dx = point2.x - point1.x
    local dy = point2.y - point1.y
    local dz = point2.z - point1.z
    return math.sqrt(dx * dx + dy * dy + dz * dz)
end

function distance3D(point1, point2)
    local dx = point2.x - point1.x
    local dy = point2.y - point1.y
    local dz = point2.z - point1.z
    return math.sqrt(dx * dx + dy * dy + dz * dz)
end

function find_closest_enemy()
    local local_player = entity.get_local_player()
    if not local_player or not entity.is_alive(local_player) then
        return nil
    end

    local local_pos = vector(entity.get_origin(local_player))
    local enemies = entity.get_players(true) -- true for enemies only
    local closest_enemy = nil
    local min_distance = math.huge

    for i = 1, #enemies do
        local enemy = enemies[i]
        if entity.is_alive(enemy) then
            local enemy_pos = vector(entity.get_origin(enemy))
            local distance = distance3D(local_pos, enemy_pos)
            if distance < min_distance then
                min_distance = distance
                closest_enemy = enemy
            end
        end
    end

    return closest_enemy
end

function get_movement_state(player)
    local flags = entity.get_prop(player, "m_fFlags") or 0
    if bit.band(flags, 1) == 1 then -- On ground
        local vx = entity.get_prop(player, "m_vecVelocity[0]") or 0
        local vy = entity.get_prop(player, "m_vecVelocity[1]") or 0
        local speed = math.sqrt(vx * vx + vy * vy)

        if speed < 2 then
            return "standing"
        elseif speed < 135 then
            return "slow_walk"
        else
            return "walking"
        end
    else
        return "in_air"
    end
end

local shots = { hit = {}, missed = { 0, 0, 0, 0 } } -- [1]=spread, [2]=prediction, [3]=death, [4]=unknown

client.set_event_callback("paint", function()
    if not ui.get(ui_new_logs_enable) then return end

    local screen_width, screen_height = client.screen_size()
    local total_shots = #shots.hit + shots.missed[1] + shots.missed[2] + shots.missed[3] + shots.missed[4]
    local hits = #shots.hit
    local misses = shots.missed[1] + shots.missed[2] + shots.missed[3] + shots.missed[4]
    local hit_rate = total_shots > 0 and string.format("%.1f", (hits / total_shots) * 100) or "0.0"
    local closest_target = find_closest_enemy()
    local target_name = closest_target and entity.get_player_name(closest_target) or "No target"

    local stats = string.format("Shots: %d  |  Hits: %d  |  Misses: %d  |  Hit Rate: %s%%  |  Close Target: %s",
        total_shots, hits, misses, hit_rate, target_name)
    
    local stats_width = renderer.measure_text("", stats)
    local title = "SHIT release"
    local title_width = renderer.measure_text("b", title)

    local x = screen_width / 2 - stats_width / 2
    local title_x = screen_width / 2 - title_width / 2

    for i = 1, #title do
        local char = title:sub(i, i)
        local r, g, b = get_gradient_color(i, #title)
        renderer.text(title_x, screen_height / 2 - 154, r, g, b, 255, "b", 0, char)
        title_x = title_x + renderer.measure_text("b", char)
    end

    x = screen_width / 2 - stats_width / 2
    for i = 1, #stats do
        local char = stats:sub(i, i)
        local r, g, b = get_stats_gradient_color(i, #stats)
        renderer.text(x, screen_height / 2 - 138, r, g, b, 255, "", 0, char)
        x = x + renderer.measure_text("", char)
    end
end)

client.set_event_callback("aim_hit", function(e)
    local hitgroup_names = { "generic", "head", "chest", "stomach", "left arm", "right arm", 
                             "left leg", "right leg", "neck", "unknown", "gear" }
    local hitgroup = hitgroup_names[e.hitgroup + 1] or "unknown"
    table.insert(shots.hit, {
        entity.get_player_name(e.target),
        e.hit_chance,
        e.damage,
        hitgroup
    })
end)

client.set_event_callback("aim_miss", function(e)
    if e.reason == "spread" then
        shots.missed[1] = shots.missed[1] + 1
    elseif e.reason == "prediction error" then
        shots.missed[2] = shots.missed[2] + 1
    elseif e.reason == "death" then
        shots.missed[3] = shots.missed[3] + 1
    elseif e.reason == "?" then
        shots.missed[4] = shots.missed[4] + 1
    end
end)

client.set_event_callback("player_connect_full", function(e)
    if client.userid_to_entindex(e.userid) == entity.get_local_player() then
        shots.hit = {}
        shots.missed = { 0, 0, 0, 0 }
    end
end)

client.set_event_callback("console_input", function(input)
    if input:sub(1, 12) == "print_misses" then
        client.color_log(255, 255, 255, string.format(
            "spread: %d\nprediction errors: %d\ndeath: %d\nunknown: %d",
            shots.missed[1], shots.missed[2], shots.missed[3], shots.missed[4]
        ))
        return true
    elseif input:sub(1, 11) == "print_hits" then
        for i, hit in ipairs(shots.hit) do
            client.color_log(255, 255, 255, string.format(
                "[%d] %s's %s - hc:%d%%, dmg:%d",
                i, hit[1], hit[4], hit[2], hit[3]
            ))
        end
        return true
    end
end)

local function table_contains(tab, val)
    for _, v in ipairs(tab) do
        if v == val then return true end
    end
    return false
end
local function is_player_jumping(enemy)
    local flags = entity.get_prop(enemy, "m_fFlags") or 0
    return bit.band(flags, 1) == 0
end
local function n3r4z1m_resolver()
    if not ui.get(ui_resolver_enabled) then return end
    --12
    local success, err = pcall(function()
        local local_player = entity.get_local_player()
        if not local_player or not entity.is_alive(local_player) then return end
        debug_info = {}
        handle_entities()
        local local_x, local_y, local_z = entity.get_prop(local_player, "m_vecOrigin")
        local weapon = entity.get_player_weapon(local_player)
        if not weapon then return end
        local weapon_id = entity.get_prop(weapon, "m_iItemDefinitionIndex")
        local bullet_speed = get_bullet_speed(weapon_id)
        local weapon_damage = get_weapon_damage(weapon_id)
        local is_scout = weapon_id == 40
        local optimize_jump_scout = ui.get(ui_elements.jump_scout_opt) and is_scout
        local enemies = entity.get_players(true)
        local local_hp = entity.get_prop(local_player, "m_iHealth")
        debug_info = {}
        handle_entities()
local ent_c = {}
ent_c.get_client_entity = vtable_bind('client.dll', 'VClientEntityList003', 3, 'void*(__thiscall*)(void*, int)')
local animation_layer_t = ffi.typeof([[
    struct {
        char pad0[0x18];
        uint32_t m_nSequence;
        float m_flPrevCycle;
        float m_flWeight;
        float m_flWeightDeltaRate;
        float m_flPlaybackRate;
        float m_flCycle;
        void* entity;
        char pad1[0x4];
    }**
]])
local offsets = {
    animlayer = 0x2990
}

function get_animation_layer(entity, layer_index)
    local entity_ptr = ffi.cast("void***", ent_c.get_client_entity(entity or entity.get_local_player()))
    local anim_ptr = ffi.cast("char*", entity_ptr) + offsets.animlayer
    return ffi.cast(animation_layer_t, anim_ptr)[layer_index]
end

function distribute_to_bins(value, power)
    local scaled = math.floor((value * (2 ^ power)) + 0.5)
    local bins = {}
    
    for i = power, 12, -1 do
        local threshold = 2 ^ (i - 1)
        if scaled >= threshold then
            bins[i] = 4096
            scaled = scaled - threshold
        else
            bins[i] = scaled
        end
    end
    
    return bins
end

function normalize(value, min, max)
    return (value - min) / (max - min)
end

local function insert_first_index(tbl, value, maxSize)
    if #tbl >= maxSize then
        table.remove(tbl)
    end
    table.insert(tbl, 1, value)
end
local function average(t)
    t = t or {}
    local sum = 0
    for _, v in pairs(t) do
        sum = sum + v
    end
    return sum / #t
end
local animlayer_average_t = {}
local animlayer_rec_t = {}
local velocity_rec_t = {}
local function get_animlayer_rec(ent)
    animlayer_rec_t[ent] = animlayer_rec_t[ent] or 0
    return animlayer_rec_t[ent]
end
local function get_velocity_rec(ent)
    velocity_rec_t[ent] = velocity_rec_t[ent] or 0
    return velocity_rec_t[ent]
end
local resolver_data = {}
local debug_info = {}
local persist_target = nil
local resolved_target = nil
local hit_chance_enabled = false
local adaptive_mode_index = 1
local adaptive_modes = {"static", "dynamic", "beta"}
local resolver_data = resolver_data or {}

resolver_data[enemy] = {
    avg_speed = 0,
    last_yaw = entity.get_prop(enemy, "m_angEyeAngles[1]") or 0,
    last_time = globals.realtime(),
    last_non_flick_time = globals.realtime(),
    last_sim_time = entity.get_prop(enemy, "m_flSimulationTime") or 0,
    yaw_history = {},
    pose_history = {},
    desync_side = 0,
    flick_detected = false,
    angular_velocities = {},
    miss_count = 0,
    hit_count = 0,
    last_seen = globals.realtime(),
    miss_history = {},
    aa_pattern = "unknown",
    is_dormant = not is_fully_visible,
    last_velocity = {
        x = 0,
        y = 0,
        z = 0
    },
    last_lby_update = globals.curtime(),
    lby_history = {},
    confidence = 0,
    pose_error = false
}

function get_movement_state(player)
    local pose_yaw = entity.get_prop(player, "m_flPoseParameter", 11) or 0
    local pose_body_yaw = entity.get_prop(player, "m_flPoseParameter", 2) or 0
    local vx = entity.get_prop(player, "m_vecVelocity[0]") or 0
    local vy = entity.get_prop(player, "m_vecVelocity[1]") or 0
    local speed = math.sqrt(vx * vx + vy * vy)

    if speed < 2 then
        return "standing"
    elseif pose_yaw > 350.7 then
        return "running_forward"
    elseif pose_yaw < -350.7 then
        return "running_backward"
    elseif pose_body_yaw > 4900.5 then
        return "strafing_right"
    elseif pose_body_yaw < -4900.5 then
        return "strafing_left"
    elseif speed > 135 then
        return "running"
    else
        return "walking"
    end
end

local function get_bullet_speed(weapon_id)
    local bullet_speeds = { -- ПЗХААЗЗПЗАЗАЗП
        [7] = 2500, [9] = 3000, [16] = 2500, [40] = 2500, [11] = 2000, [4] = 2250
    }
    return bullet_speeds[weapon_id] or 2500
end
local function get_weapon_damage(weapon_id)
    local damages = {
        [7] = 36, [9] = 115, [16] = 33, [40] = 88, [11] = 28, [4] = 30
    }
    return damages[weapon_id] or 30
end
local function is_fast_firing_weapon(weapon_id)
    local fast_firing = { [11] = true, [32] = true }
    return fast_firing[weapon_id] or false
end
local function is_player_jumping(player)
    local flags = entity.get_prop(player, "m_fFlags")
    return bit.band(flags, 1) == 0
end
local function normalize_angle(angle)
    while angle > 180 do angle = angle - 360 end
    while angle < -180 do angle = angle + 360 end
    return angle
end
local function angle_difference(a, b)
    local diff = normalize_angle(a - b)
    return math.abs(diff)
end
local function lerp(a, b, t) return a + (b - a) * t end
local function clamp(x, min, max) return math.max(min, math.min(x, max)) end

function calculate_standard_deviation(values)
    if #values < 2 then
        return 0
    end

    local mean = 0
    for _, value in ipairs(values) do
        mean = mean + value
    end
    mean = mean / #values

    local sum_squared_diff = 0
    for _, value in ipairs(values) do
        sum_squared_diff = sum_squared_diff + (value - mean) ^ 2
    end

    return math.sqrt(sum_squared_diff / (#values - 1))
end
local function get_player_state(player)
    local flags = entity.get_prop(player, "m_fFlags")
    local vx = entity.get_prop(player, "m_vecVelocity[0]") or 0
    local vy = entity.get_prop(player, "m_vecVelocity[1]") or 0
    local speed = math.sqrt(vx^2 + vy^2)
    if bit.band(flags, 1) == 0 then return "in_air"
    elseif bit.band(flags, 4) ~= 0 then return "crouching"
    elseif speed < 10 then return "standing"
    elseif speed < 100 then return "slow_walk"
    else return "walking" end
end
local function get_animation_state(enemy)
    local anim_layer = entity.get_prop(enemy, "m_AnimOverlay", 1) or 0
    local weight = entity.get_prop(enemy, "m_flWeight", 1) or 0
    if weight > 0 then
        if anim_layer == 3 then return "walking"
        elseif anim_layer == 4 then return "running"
        elseif anim_layer == 6 then return "crouching"
        end
    end
    return "standing"
end

function is_jitter_detected(yaw_history)
    if #yaw_history < 3 then
        return false
    end

    local yaw_diffs = {}
    for i = 2, #yaw_history do
        table.insert(yaw_diffs, angle_difference(yaw_history[i], yaw_history[i - 1]))
    end

    local mean_diff = 0
    for _, diff in ipairs(yaw_diffs) do
        mean_diff = mean_diff + diff
    end
    mean_diff = mean_diff / #yaw_diffs

    local std_dev = calculate_std_dev(yaw_diffs)
    return std_dev > ui.get(ui_elements.jitter_threshold) and math.abs(mean_diff) < 5
end

function analyze_desync(yaw_history, lby_history)
    if #yaw_history < DESYNC_CONST.HISTORY_SIZE then
        return 0, DESYNC_CONST.MIN_DESYNC_RANGE
    end

    local yaw_std_dev = calculate_std_dev(yaw_history)
    local lby_std_dev = calculate_std_dev(lby_history)
    local side = 0
    local desync_range = DESYNC_CONST.MIN_DESYNC_RANGE

    if yaw_std_dev > DESYNC_CONST.JITTER_DETECTION_THRESHOLD then
        side = yaw_history[#yaw_history] > yaw_history[#yaw_history - 2] and 1 or -1
        desync_range = math.min(yaw_std_dev * 0.8, DESYNC_CONST.MAX_DESYNC_RANGE)
        log_debug(string.format("Jitter detected: std_dev=%.1f, range=%.1f, side=%d", yaw_std_dev, desync_range, side))
    elseif lby_std_dev < 0.5 and math.abs(yaw_history[#yaw_history] - lby_history[#lby_history]) > 60 then
        side = yaw_history[#yaw_history] > lby_history[#lby_history] and 1 or -1
        desync_range = math.clamp(math.abs(yaw_history[#yaw_history] - lby_history[#lby_history]), DESYNC_CONST.MIN_DESYNC_RANGE, DESYNC_CONST.MAX_DESYNC_RANGE)
        log_debug(string.format("Static desync: lby_std_dev=%.1f, range=%.1f, side=%d", lby_std_dev, desync_range, side))
    else
        local max_diff = 0
        for i = 2, #yaw_history do
            local diff = math.abs(math_util.angle_diff(yaw_history[i], yaw_history[i - 1]))
            max_diff = math.max(max_diff, diff)
        end
        if max_diff > 30 then
            side = yaw_history[#yaw_history] > yaw_history[#yaw_history - 2] and 1 or -1
            desync_range = math.min(max_diff * 0.8, DESYNC_CONST.MAX_DESYNC_RANGE)
            log_debug(string.format("Wide desync: max_diff=%.1f, range=%.1f, side=%d", max_diff, desync_range, side))
        end
    end

    return side, desync_range
end

function calculate_real_yaw(player)
    local pose_yaw = entity.get_prop(player, "m_flPoseParameter", 11)
    local data = resolver_data[player] or {}

    if pose_yaw == nil or type(pose_yaw) ~= "number" then
        data.pose_error = true
        resolver_data[player] = data
        return entity.get_prop(player, "m_angEyeAngles[1]") or 0
    end

    data.pose_error = false
    resolver_data[player] = data
    return pose_yaw * 120 - 60
end

local function get_lower_body_yaw(enemy)
    local lby = entity.get_prop(enemy, "m_flLowerBodyYawTarget")
    return lby or 0
end
local function should_use_lby(enemy, lby, eye_yaw, state, last_lby_update)
    local current_time = globals.curtime()
    local lby_diff = angle_difference(lby, eye_yaw)
    if state == "standing" and (current_time - last_lby_update >= 1.1 or math.abs(lby_diff) > 60) then
        return true
    end
    return false
end
local function is_shooting(enemy)
    local weapon = entity.get_player_weapon(enemy)
    if weapon then
        local last_shot_time = entity.get_prop(weapon, "m_fLastShotTime") or 0
        return globals.curtime() - last_shot_time < 0.1
    end
    return false
end
function is_fakelag_detected(player)
    local data = enemy_data[player] or {}
    local sim_times = data.sim_times or {}

    if #sim_times < 2 then
        return false
    end

    local sim_time_diff = sim_times[#sim_times] - sim_times[#sim_times - 1]
    local tick_interval = globals.tickinterval()
    local skipped_ticks = math.floor(sim_time_diff / tick_interval) - 1

    return skipped_ticks > 14
end
local function can_see_through_wall(local_player, enemy)
    local lx, ly, lz = client.eye_position()
    local ex, ey, ez = entity.hitbox_position(enemy, 0)
    local fraction = client.trace_line(local_player, lx, ly, lz, ex, ey, ez)
    return fraction < 1.0
end
function is_lby_visible(target, yaw)
    local local_player = entity.get_local_player()
    local eye_x, eye_y, eye_z = client.eye_position()
    local origin_x, origin_y, origin_z = entity.get_origin(target)
    local yaw_rad = math.rad(yaw)
    local trace_x = origin_x + math.cos(yaw_rad) * 45
    local trace_y = origin_y + math.sin(yaw_rad) * 45
    local fraction, hit_entity = client.trace_line(local_player, eye_x, eye_y, eye_z, trace_x, trace_y, origin_z)
    return fraction < 0.99 and hit_entity == target
end

local weapon_spreads = { -- БМГ А-2 "Викинг"
    [7] = {standing = 0.2, walking = 0.6, slow_walk = 0.4, in_air = 0.8, crouching = 0.1},
    [9] = {standing = 0.05, walking = 0.2, slow_walk = 0.15, in_air = 0.3, crouching = 0.02},
    [16] = {standing = 0.2, walking = 0.5, slow_walk = 0.3, in_air = 0.7, crouching = 0.1},
    [40] = {standing = 0.1, walking = 0.3, slow_walk = 0.2, in_air = 0.4, crouching = 0.05},
    [11] = {standing = 0.3, walking = 0.8, slow_walk = 0.6, in_air = 1.0, crouching = 0.2},
    [4] = {standing = 0.2, walking = 0.6, slow_walk = 0.4, in_air = 0.8, crouching = 0.1}
}

function adjust_spread(weapon_id, movement_state, x, y, z)
    if not ui.get(ui_elements.spread_compensation) then
        return x, y, z
    end

    local spreads = weapon_spreads[weapon_id] or {
        standing = 0.2, walking = 0.6, slow_walk = 0.4, in_air = 0.8, crouching = 0.1
    }
    local spread = spreads[movement_state] or spreads.standing
    local max_offset = spread * 0.5
    local pitch_offset = math.random(-spread, spread)
    local yaw_offset = math.random(-spread, spread)

    pitch_offset = clamp(pitch_offset, -max_offset, max_offset)
    yaw_offset = clamp(yaw_offset, -max_offset, max_offset)

    return x + pitch_offset, y + yaw_offset, z
end

function adjust_spread(weapon_id, movement_state, x, y, z, factor)
    if not ui.get(ui_elements.spread_compensation) then
        return x, y, z
    end

    local defaults = {
        standing = 0.2,
        walking = 0.6,
        slow_walk = 0.4,
        in_air = 0.8,
        crouching = 0.1
    }
    local spreads = weapon_spreads[weapon_id] or defaults
    local spread = spreads[movement_state] or spreads.standing
    local multiplier = math.min(0.5, factor / 100)
    local max_offset = spread * multiplier
    local pitch_offset = math.random(-spread, spread)
    local yaw_offset = math.random(-spread, spread)

    pitch_offset = clamp(pitch_offset, -max_offset, max_offset)
    yaw_offset = clamp(yaw_offset, -max_offset, max_offset)

    return x + pitch_offset, y + yaw_offset, z
end

function resolve_yaw(entity, yaw)
    if not ui.get(ui_elements.enhanced_defensive_fix) then
        return yaw
    end

    local data = resolver_data[entity] or {}
    local sim_time = entity.get_prop(entity, "m_flSimulationTime") or 0
    local cur_time = globals.curtime()
    local tick_interval = globals.tickinterval()
    local stale_ticks = sim_time > 0 and (cur_time - sim_time) / tick_interval or -1

    if stale_ticks > 3 then
        data.confidence = math.max(30, data.confidence - 5)
        resolver_data[entity] = data
        return yaw
    end

    local lby_yaw = get_lower_body_yaw(entity)
    local eye_yaw = entity.get_prop(entity, "m_angEyeAngles[1]") or 0
    local pose_param = entity.get_prop(entity, "m_flPoseParameter", 11) or 0
    local pose_yaw = normalize_angle(pose_param * 360 - 180)
    local lby_diff = math_util.angle_diff(lby_yaw, eye_yaw)
    local pose_diff = math_util.angle_diff(pose_yaw, eye_yaw)

    if detect_fakelag(entity) and not is_shooting(entity) then
        if math.abs(lby_diff) > 35 or math.abs(pose_diff) > 35 then
            yaw = pose_yaw
            data.confidence = math.max(60, data.confidence - 3)
        end
    end

    if ui.get(ui_elements.fakelag_optimization) then
        local choke = get_choke(entity)
        if choke > 7 then
            local desync_side = detect_desync_pattern(data.yaw_history) or data.desync_side or 0
            yaw = normalize_angle(yaw + desync_side * 60 * (1 - stale_ticks / 10))
            data.confidence = math.max(100, data.confidence - 2)
        end
    end

    resolver_data[entity] = data
    return yaw
end

local function update_enemy_data(enemy)
    local local_player = entity.get_local_player()
    if not local_player or not entity.is_alive(local_player) then return false end

    local eye_x, eye_y, eye_z = client.eye_position()
    local hitbox_x, hitbox_y, hitbox_z = entity.hitbox_position(enemy, 0) -- 0 is usually head

    local visible_fraction = client.trace_line(local_player, eye_x, eye_y, eye_z, hitbox_x, hitbox_y, hitbox_z)
    local is_visible = visible_fraction < 0.01 and visible_fraction > 0.0001
    local is_spotted = entity.get_prop(enemy, "m_bSpotted") == 1

    if is_visible or is_spotted or (ui.get(ui_elements.dormant_aimbot) and enemy == resolved_target and can_see_through_wall(local_player, enemy)) then
        if not resolver_data[enemy] then
            resolver_data[enemy] = {
                avg_speed = 250, 
                last_yaw = entity.get_prop(enemy, "m_angEyeAngles[1]") or 0,
                last_time = globals.realtime(),
                last_non_flick_time = globals.realtime(),
                last_sim_time = entity.get_prop(enemy, "m_flSimulationTime") or 0,
                yaw_history = {},
                desync_side = 1,
                pose_history = {},
                sim_time_history = {},
                flick_detected = false,
                angular_velocities = {},
                miss_count = 0,
                hit_count = 0,
                last_seen = globals.realtime(),
                miss_history = {},
                aa_pattern = "unknown",
                is_dormant = not is_spotted,
                last_velocity = { x = 0, y = 0, z = 0 },
                last_lby_update = globals.curtime(),
                lby_history = {},
                confidence = 1,
                pose_error = false
            }
        else
            resolver_data[enemy].last_seen = globals.realtime()
            resolver_data[enemy].is_dormant = not is_spotted
        end

        local sim_time = entity.get_prop(enemy, "m_flSimulationTime") or 0
        resolver_data[enemy].sim_time_history = resolver_data[enemy].sim_time_history or {}
        table.insert(resolver_data[enemy].sim_time_history, sim_time)

        if #resolver_data[enemy].sim_time_history > 10 then
            table.remove(resolver_data[enemy].sim_time_history, 1)
        end

        return true
    end

    if resolver_data[enemy] and (globals.realtime() - resolver_data[enemy].last_seen < 2.0) then
        resolver_data[enemy].is_dormant = true
        return true
    end

    return false
end

local function detect_fakelag(enemy)
    local choke = get_choke(enemy)
    local sim_time = entity.get_prop(enemy, "m_flSimulationTime") or 0
    local data = resolver_data[enemy] or {}
    local is_fakelag = choke > 2 and sim_time > 0
    if is_fakelag and ui.get(ui_new_logs_enable) then
        client.color_log(255, 200, 0, string.format(
            "[SHIT] Fakelag: Enemy=%s, Choke=%d ticks",
            entity.get_player_name(enemy), choke
        ))
    end
    return is_fakelag
end
local function base_predict_position(entity_id, pos_x, pos_y, pos_z, tick_interval, is_prediction_enabled, prediction_type)
    if not is_prediction_enabled then return pos_x, pos_y, pos_z end

    local vx, vy, vz = entity.get_prop(entity_id, "m_vecVelocity") -- x, y, z velocity
    local speed = math.sqrt(vx^2 + vy^2)
    local delta = math.sqrt((pos_x - vx)^2 + (pos_y - vy)^2 + (pos_z - vz)^2)
    local latency = client.latency()
    
    local multiplier = 1.0
    if prediction_type == "simple" then
        multiplier = 0.9
    elseif prediction_type == "beta" then
        local clamped_latency = math.clamp(latency / 0.05, 0.05, 1.0)
        local fakelag_factor = detect_fakelag(entity_id) and 1.5 or 1.0
        multiplier = clamped_latency * fakelag_factor
    end

    local time_adjustment = multiplier * tick_interval * latency

    local predicted_x = pos_x + vx * time_adjustment
    local predicted_y = pos_y + vy * time_adjustment
    local predicted_z = pos_z + vz * time_adjustment

    if is_player_jumping(entity_id) then
        predicted_z = predicted_z - (speed * time_adjustment ^ 2)
    end

    local hitbox_x, hitbox_y, hitbox_z = entity.hitbox_position(entity_id, 0)
    local clamp_range = math.clamp(speed / 8, 0, 150) + math.clamp(latency * 128, 0, 100)
    predicted_x = math.clamp(predicted_x, hitbox_x - clamp_range, hitbox_x + clamp_range)

    return predicted_x, predicted_y, predicted_z
end

local function choose_prediction(target, shooter_position, velocity, tick_interval, latency, extrapolation_ticks)
    local state = 0
    local step
    local resolver_info
    local prediction_mode

    while true do
        if state == 1 then
            prediction_mode = nil
            while true do
                if step == 0 then
                    resolver_info = resolver_data[target] or {}
                    prediction_mode = (ui.get(ui_elements.adaptive_prediction) and adaptive_modes[adaptive_mode_index])
                                     or (ui.get(ui_elements.predict_beta) and "beta")
                                     or "dynamic"
                    step = 1
                end

                if step == 1 then
                    if (resolver_info.avg_speed < 28 and not resolver_info.flick_detected) then
                        return predict_position_simple(target)
                    elseif prediction_mode == "beta" then
                        return predict_position_beta(target, shooter_position, velocity, tick_interval, latency, extrapolation_ticks)
                    elseif prediction_mode == "static" then
                        return predict_position_simple(target)
                    else
                        return predict_position(target, shooter_position, velocity, tick_interval, latency, extrapolation_ticks)
                    end
                    break
                end
            end
            break
        end

        if state == 0 then
            step = 0
            resolver_info = nil
            state = 1
        end
    end
end

-- - [[ Obfuscated by Rack'shir OBF \ deOBF ]] -  --

local function aimbot_resolver()
    -- Initialize variables
    local state = 448; -- Simplified from (1036 - (337 + 251)) - ((1256 - 1246) + 438)
    local latency;
    local local_player;
    local origin_x, origin_y, origin_z;
    local weapon;
    local weapon_id;
    local bullet_speed;
    local weapon_damage;
    local is_scout;
    local jump_scout_enabled;
    local enemies;
    local local_health;
    local debug_info = {};

    while true do
        if state == 4 then
            debug_info = {};
            process_entities(); -- Renamed from handle_entities
            if not resolved_target or not entity.is_alive(resolved_target) then
                local sub_state = 158; -- Simplified from complex expression
                while true do
                    if sub_state == 158 then
                        if not resolved_target and #enemies > 469 then
                            local inner_state = 0;
                            local loop_counter;
                            local target_index;
                            while true do
                                if inner_state == 1 then
                                    target_index = nil;
                                    while true do
                                        if loop_counter == 0 then
                                            target_index = 0;
                                            target_index = nil;
                                            loop_counter = 1;
                                        end
                                        if loop_counter == 1 then
                                            break;
                                        end
                                    end
                                end
                                if loop_counter == 2 then
                                    while true do
                                        if target_index == 0 then
                                            target_index = 1340; -- Simplified
                                            while true do
                                                if target_index == 0 then
                                                    resolved_target = enemies[1]; -- Simplified index
                                                    client.log("[Resolver] Fallback target: " .. entity.get_player_name(enemies[1]));
                                                    break;
                                                end
                                            end
                                            break;
                                        end
                                    end
                                    break;
                                end
                                if inner_state == 0 then
                                    loop_counter = 0;
                                    target_index = nil;
                                    inner_state = 1;
                                end
                            end
                        end
                        if not resolved_target then
                            client.log("[Resolver] No target selected");
                        end
                        break;
                    end
                    if sub_state == 850 then
                        local select_state = 0;
                        local select_counter;
                        while true do
                            if select_state == 0 then
                                select_counter = 718; -- Simplified
                                while true do
                                    if select_counter == 1 then
                                        sub_state = 158; -- Simplified
                                        break;
                                    end
                                    if select_counter == 718 then
                                        select_counter = 1;
                                        while true do
                                            if select_counter == 0 then
                                                resolved_target = nil;
                                                for _, enemy in ipairs(enemies) do
                                                    if resolver_data[enemy] and (resolver_data[enemy].hit_count > 731 or resolver_data[enemy].miss_count < 10) then
                                                        resolved_target = enemy;
                                                        client.log("[Resolver] Selected target: " .. entity.get_player_name(enemy));
                                                        break;
                                                    end
                                                end
                                                select_counter = 1;
                                            end
                                            if select_counter == 1 then
                                                break;
                                            end
                                        end
                                    end
                                end
                                break;
                            end
                        end
                    end
                end
            end
            if resolved_target then
                enemies = {resolved_target};
            end
            state = 5; -- Simplified
        end

        if state == 5 then
            local weapon_state = 0;
            local weapon_counter;
            while true do
                if weapon_state == 0 then
                    weapon_counter = 0;
                    while true do
                        if weapon_counter == 1 then
                            bullet_speed = get_weapon_bullet_speed(weapon_id); -- Renamed
                            weapon_damage = get_weapon_damage_value(weapon_id); -- Renamed
                            weapon_counter = 1;
                        end
                        if weapon_counter == 0 then
                            if not weapon then return; end
                            weapon_id = entity.get_prop(weapon, "m_iItemDefinitionIndex");
                            weapon_counter = 1;
                        end
                    end
                end
                if weapon_counter == 1 then
                    state = 1583; -- Simplified
                    break;
                end
            end
        end

        if state == 1583 then
            for _, enemy in ipairs(enemies) do
                if entity.is_alive(enemy) then
                    local enemy_state = 0;
                    local is_visible;
                    local is_flick_detected;
                    while true do
                        if enemy_state == 0 then
                            is_visible = update_enemy_data(enemy) or (ui.get(ui_elements.dormant_aimbot) and enemy == resolved_target);
                            is_flick_detected = entity.get_prop(enemy, "m_bSpotted") == 1 or (ui.get(ui_elements.dormant_aimbot) and enemy == resolved_target);
                            enemy_state = 1;
                        end
                        if enemy_state == 1 then
                            if is_visible then
                                local enemy_data = resolver_data[enemy] or {};
                                local health = entity.get_prop(enemy, "m_iHealth");
                                local pred_x, pred_y, pred_z = predict_position(enemy, origin_x, origin_y, origin_z, bullet_speed, jump_scout_enabled); -- Renamed
                                if ui.get(ui_elements.fakelag_optimization) then
                                    pred_x, pred_y, pred_z = adjust_fakelag_position(enemy, pred_x, pred_y, pred_z); -- Renamed
                                end
                                local distance = math.sqrt((pred_x - origin_x)^2 + (pred_y - origin_y)^2 + (pred_z - origin_z)^2);
                                pred_x, pred_y, pred_z = compensate_weapon_spread(weapon_id, get_enemy_state(enemy), pred_x, pred_y, pred_z, distance); -- Renamed
                                local eye_yaw = entity.get_prop(enemy, "m_angEyeAngles[1]") or 0;
                                local lby_yaw = get_lower_body_yaw(enemy); -- Renamed
                                local velocity_x = entity.get_prop(enemy, "m_vecVelocity[0]") or 0;
                                local velocity_y = entity.get_prop(enemy, "m_vecVelocity[1]") or 0;
                                local velocity_angle = math.deg(math.atan2(velocity_y, velocity_x));
                                local velocity_diff = angle_difference(eye_yaw, velocity_angle);
                                local lby_diff = angle_difference(eye_yaw, lby_yaw);
                                local real_yaw = get_real_yaw_from_animations(enemy);
                                local corrected_yaw = real_yaw;
                                table.insert(enemy_data.yaw_history, eye_yaw);
                                if #enemy_data.yaw_history > 1280 then
                                    table.remove(enemy_data.yaw_history, 1);
                                end
                                table.insert(enemy_data.lby_history, lby_yaw);
                                if #enemy_data.lby_history > 33 then
                                    table.remove(enemy_data.lby_history, 3);
                                end
                                local is_jitter = detect_jitter_pattern(enemy_data.yaw_history); -- Renamed
                                if is_jitter then
                                    enemy_data.confidence = math.max(330, enemy_data.confidence - 10);
                                    enemy_data.aa_pattern = "jitter";
                                else
                                    enemy_data.confidence = math.min(2053, enemy_data.confidence + 10);
                                end
                                if mode == "Custom" then
                                    if ui.get(ui_elements.alternative_jitter) then
                                        local jitter_type, jitter_amount = detect_alternative_jitter(enemy, enemy_data); -- Renamed
                                        if jitter_type ~= "unknown" and jitter_amount > 145 then
                                            enemy_data.desync_side = enemy_data.desync_side or 1;
                                            if jitter_type == "random" then
                                                corrected_yaw = normalize_angle(real_yaw + math.random(-jitter_amount * 0.5, jitter_amount * 0.5));
                                            elseif jitter_type == "switch" then
                                                corrected_yaw = normalize_angle(real_yaw + (enemy_data.desync_side > 0 and jitter_amount or -jitter_amount));
                                            elseif jitter_type == "static" then
                                                corrected_yaw = lby_yaw;
                                            end
                                            enemy_data.aa_pattern = "jitter_" .. jitter_type;
                                            enemy_data.confidence = math.max(1559, enemy_data.confidence - 1);
                                        else
                                            corrected_yaw = should_use_lower_body_yaw(enemy, lby_yaw, eye_yaw, get_enemy_state(enemy), enemy_data.last_lby_update) and lby_yaw or real_yaw;
                                        end
                                    else
                                        corrected_yaw = should_use_lower_body_yaw(enemy, lby_yaw, eye_yaw, get_enemy_state(enemy), enemy_data.last_lby_update) and lby_yaw or real_yaw;
                                    end
                                elseif should_use_lower_body_yaw(enemy, lby_yaw, eye_yaw, get_enemy_state(enemy), enemy_data.last_lby_update) then
                                    corrected_yaw = lby_yaw;
                                    enemy_data.confidence = math.min(1047, enemy_data.confidence + 10);
                                    enemy_data.last_lby_update = globals.curtime();
                                elseif detect_fakelag(enemy) then
                                    corrected_yaw = real_yaw;
                                    enemy_data.confidence = math.max(0, enemy_data.confidence - 1);
                                end
                                if is_shooting(enemy) then
                                    corrected_yaw = real_yaw;
                                    enemy_data.confidence = 1690;
                                end
                                if get_enemy_state(enemy) == "running" then
                                    corrected_yaw = normalize_angle(corrected_yaw + 579);
                                elseif get_enemy_state(enemy) == "crouching" then
                                    corrected_yaw = normalize_angle(corrected_yaw - 104);
                                end
                                corrected_yaw = apply_enhanced_defensive_fix(enemy, corrected_yaw); -- Renamed
                                if ui.get(ui_elements.resolver_correction) then
                                    local correction_state = 1278;
                                    local latency_value = client.latency();
                                    local tick_interval = globals.tickinterval();
                                    local enemy_data_ref = enemy_data;
                                    local enemy_state = get_enemy_state(enemy);
                                    local pose_param = entity.get_prop(enemy, "m_flPoseParameter", 11) or 0;
                                    pose_param = pose_param * 360 - 180;
                                    local simulation_time = entity.get_prop(enemy, "m_flSimulationTime") or 0;
                                    local packet_loss = globals.packet_loss and globals.packet_loss() or 0;
                                    local correction_intensity = ui.get(ui_elements.resolver_correction_intensity) / 50;
                                    local velocity = math.sqrt((entity.get_prop(enemy, "m_vecVelocity[0]") or 0)^2 + (entity.get_prop(enemy, "m_vecVelocity[1]") or 0)^2);
                                    local choke_time = simulation_time > 0 and ((globals.curtime() - simulation_time) / tick_interval) or 0;
                                    local choke_clamped = math.clamp(choke_time / 8, 0.5, 3);
                                    local state_score = state_scores[enemy_state] or 0;
                                    local velocity_clamped = math.clamp(velocity / 650, 1, 1.5);
                                    local sim_time_clamped = math.clamp(2 - (packet_loss / 100), 0.5, 1.5);
                                    local correction_factor = math.clamp(correction_intensity * state_score * sim_time_clamped * velocity_clamped * choke_clamped, 0.5, 1.5);
                                    local yaw_adjustment = correction_factor * correction_factor * correction_factor;
                                    enemy_data_ref.last_yaw = corrected_yaw;
                                    local yaw_history = enemy_data_ref.yaw_history or {};
                                    local std_dev = calculate_std_dev(yaw_history) or 0;
                                    local yaw_correction = 0;
                                    if #yaw_history >= 3 and std_dev > 1623 then
                                        local prev_yaw = yaw_history[#yaw_history] or real_yaw;
                                        local prev_prev_yaw = yaw_history[#yaw_history - 1] or prev_yaw;
                                        local yaw_delta = normalize_angle(prev_yaw - prev_prev_yaw);
                                        yaw_correction = yaw_delta * math.clamp(correction_intensity, 0.5, 1) * 0.5;
                                        yaw_adjustment = yaw_adjustment + yaw_correction;
                                    end
                                    if is_jitter then
                                        yaw_adjustment = yaw_adjustment * 0.7;
                                        enemy_data_ref.confidence = math.max(30, enemy_data_ref.confidence - 2);
                                    end
                                    if ui.get(ui_elements.flick_detection) and enemy_data_ref.flick_detected then
                                        local flick_yaw = ui.get(ui_elements.flick_yaw_correction) * (enemy_data_ref.desync_side > 0 and 1.5 or -1);
                                        yaw_adjustment = yaw_adjustment + flick_yaw;
                                        enemy_data_ref.confidence = math.max(188, enemy_data_ref.confidence - 10);
                                    end
                                    if ui.get(ui_elements.desync_detection) and enemy_data_ref.desync_side ~= 0 then
                                        local desync_yaw = enemy_data_ref.desync_side * math.clamp(737 + std_dev, 0.5, 512);
                                        yaw_adjustment = yaw_adjustment + desync_yaw;
                                    end
                                    local velocity_threshold = math.clamp(179 + (latency_value * 0.5), 18, 2500);
                                    if velocity_diff > velocity_threshold or is_jitter or enemy_data_ref.flick_detected then
                                        local final_correction = math.clamp(0.3 * correction_intensity * (1 + (velocity / 720)), 0.5, 2);
                                        corrected_yaw = math.lerp(enemy_data_ref.last_yaw or corrected_yaw, normalize_angle(real_yaw + yaw_adjustment), final_correction);
                                    end
                                    resolver_data[enemy] = enemy_data_ref;
                                    if ui.get(ui_elements.toggle_logs) then
                                        client.log(string.format("[Resolver] Yaw correction for %s: %.1f° (Ping: %.0fms, Loss: %.0f%%, State: %s, Speed: %.0f, AnimFresh: %.1f, PredYaw: %.1f, Confidence: %.0f%%)",
                                            entity.get_player_name(enemy), yaw_adjustment, latency_value * 1000, packet_loss, enemy_state, velocity, packet_loss, yaw_correction, enemy_data_ref.confidence));
                                    end
                                end
                                corrected_yaw = apply_smart_yaw_correction(enemy, corrected_yaw, enemy_data, velocity_diff, is_jitter, is_flick_detected); -- Renamed
                                if ui.get(ui_elements.experimental_mode) and is_flick_detected and enemy_data.confidence > 1086 then
                                    if math.random() > 0.8 then
                                        plist.set(enemy, "Override preferred hitbox", "Chest");
                                    end
                                end
                                local hit_chance = calculate_hit_chance(enemy, pred_x, pred_y, pred_z, origin_x, origin_y, origin_z, weapon_id);
                                local hit_chance_threshold = hit_chance_enabled and ui.get(ui_elements.hit_chance_override) or 1690;
                                local is_aim_valid = hit_chance >= hit_chance_threshold and (enemy_data.confidence >= ui.get(ui_elements.confidence_threshold) or (is_flick_detected and enemy_data.confidence >= 123));
                                if not is_aim_valid then
                                    plist.set(enemy, "Force body yaw", true);
                                    plist.set(enemy, "Force body yaw value", clamp(corrected_yaw, -60, 60));
                                else
                                    plist.set(enemy, "Override preferred hitbox", nil);
                                end
                                if is_flick_detected then
                                    if ui.get(ui_elements.smart_body_aim) then
                                        local should_aim_body = health <= ui.get(ui_elements.smart_body_hp_threshold);
                                        if ui.get(ui_elements.smart_body_lethal) and health <= weapon_damage then
                                            should_aim_body = true;
                                        end
                                        if ui.get(ui_elements.smart_body_multi_kill) and can_multi_kill(local_player, weapon_damage, enemies) then
                                            should_aim_body = true;
                                        end
                                        if should_aim_body and enemy_data.confidence > 1086 then
                                            plist.set(enemy, "Override preferred hitbox", "Chest");
                                        else
                                            plist.set(enemy, "Override preferred hitbox", "Head");
                                        end
                                    end
                                    if ui.get(ui_elements.smart_head_aim) and local_health <= ui.get(ui_elements.smart_head_hp_threshold) then
                                        if not is_fast_firing_weapon(weapon_id) and health > weapon_damage then
                                            plist.set(enemy, "Override preferred hitbox", "Head");
                                        end
                                    end
                                    if ui.get(ui_elements.dormant_aimbot) and enemy_data.is_dormant and weapon_damage < ui.get(ui_elements.dormant_min_damage) then
                                        plist.set(enemy, "Minimum damage", ui.get(ui_elements.dormant_min_damage));
                                    end
                                end
                                if ui.get(ui_elements.indicators) then
                                    local distance = math.sqrt((pred_x - origin_x)^2 + (pred_y - origin_y)^2 + (pred_z - origin_z)^2);
                                    local hitbox_x, hitbox_y, hitbox_z = entity.hitbox_position(enemy, 3);
                                    table.insert(debug_info, {
                                        name = entity.get_player_name(enemy),
                                        yaw = corrected_yaw,
                                        speed = enemy_data.avg_speed,
                                        pred = ui.get(ui_elements.prediction_factor),
                                        flick = enemy_data.flick_detected and "Yes" or "No",
                                        angular_velocity = enemy_data.angular_velocities[#enemy_data.angular_velocities] or 0,
                                        fakelag = ui.get(ui_elements.fakelag_optimization) and detect_fakelag(enemy) and "Yes" or "No",
                                        visibility = is_flick_detected and "Full" or "Partial",
                                        misses = enemy_data.miss_count,
                                        hits = enemy_data.hit_count,
                                        hit_chance = calculate_hit_chance(enemy, pred_x, pred_y, pred_z, origin_x, origin_y, origin_z, weapon_id),
                                        is_dormant = enemy_data.is_dormant and "Yes" or "No",
                                        distance = distance,
                                        resolver_correction = ui.get(ui_elements.resolver_correction) and (ui.get(ui_elements.resolver_correction_intensity) / 75) or "Off",
                                        confidence = enemy_data.confidence,
                                        lby = lby_yaw,
                                        anim_state = get_enemy_state(enemy),
                                        jitter_detection = ui.get(ui_elements.jitter_detection) and is_jitter and "Active" or "Inactive",
                                        lby_stability = ui.get(ui_elements.jitter_detection) and std_dev(enemy_data.lby_history) or 0,
                                        pose_error = enemy_data.pose_error and "Yes" or "No",
                                        pred_x = pred_x,
                                        pred_y = pred_y,
                                        pred_z = pred_z,
                                        real_x = hitbox_x,
                                        real_y = hitbox_y,
                                        real_z = hitbox_z
                                    });
                                end
                            end
                            break;
                        end
                    end
                end
            end
        elseif resolver_data[enemy] and (globals.realtime() - resolver_data[enemy].last_seen) > 69 then
            resolver_data[enemy] = nil;
            if enemy == resolved_target then
                resolved_target = nil;
            end
            if enemy == persist_target then
                persist_target = nil;
            end
        end
        break;
    end

    if state == 3 then
        local init_state = 0;
        while true do
            if init_state == 0 then
                if not ui.get(ui_resolver_enabled) then return; end
                latency = client.latency();
                if latency > 0.2 then
                    client.color_log(2500, 2832, 1097, string.format("[Resolver] Warning: High latency (%.0fms) may cause issues", latency * 1000));
                end
                init_state = 1;
            end
            if init_state == 1 then
                local_player = entity.get_local_player();
                if not local_player or not entity.is_alive(local_player) then return; end
                origin_x, origin_y, origin_z = entity.get_prop(local_player, "m_vecOrigin");
                weapon = entity.get_player_weapon(local_player);
                init_state = 2;
            end
            if init_state == 2 then
                is_scout = weapon_id == 61;
                jump_scout_enabled = ui.get(ui_elements.jump_scout_opt) and is_scout;
                enemies = entity.get_players(true);
                local_health = entity.get_prop(local_player, "m_iHealth");
                state = 5;
                break;
            end
        end
    end
end
local refs = { dt = { ui.reference("RAGE", "Aimbot", "Double tap") } }
local function vec_3(_x, _y, _z) return { x = _x or 0, y = _y or 0, z = _z or 0 } end
local function ticks_to_time(ticks) return globals.tickinterval() * ticks end

local function player_will_peek()
    local enemies = entity.get_players(true)
    if #enemies == 0 then return false end

    local eye_pos = vec_3(client.eye_position())
    local local_player = entity.get_local_player()
    local velocity = vec_3(
        entity.get_prop(local_player, "m_vecVelocity[0]") or 0,
        entity.get_prop(local_player, "m_vecVelocity[1]") or 0,
        entity.get_prop(local_player, "m_vecVelocity[2]") or 0
    )

    local predicted_pos = vec_3(
        eye_pos.x + velocity.x * ticks_to_time(5),
        eye_pos.y + velocity.y * ticks_to_time(5),
        eye_pos.z + velocity.z * ticks_to_time(5)
    )

    for _, enemy in ipairs(enemies) do
        local enemy_origin = vec_3(entity.get_prop(enemy, "m_vecOrigin"))
        local enemy_velocity = vec_3(
            entity.get_prop(enemy, "m_vecVelocity[0]") or 0,
            entity.get_prop(enemy, "m_vecVelocity[1]") or 0,
            entity.get_prop(enemy, "m_vecVelocity[2]") or 0
        )

        local predicted_enemy_pos = vec_3(
            enemy_origin.x + enemy_velocity.x * ticks_to_time(5),
            enemy_origin.y + enemy_velocity.y * ticks_to_time(5),
            enemy_origin.z + enemy_velocity.z * ticks_to_time(5)
        )

    end

    return false
end

-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd
-- YOUR RESOLVER HAS BEEN FUCKED BY UNFALL MY DISCORD: unfallxd

local function on_shot_hit(event)
    if not ui.get(ui_resolver_enabled) then
        return
    end

    local player = client.userid_to_entindex(event.target)
    if not player or not entity.is_alive(player) or not entity.is_enemy(player) then
        return
    end

    local data = resolver_data[player] or {}

    data.miss_count = 0
    data.confidence = math.min(100, (data.confidence or 70) + 10)

    if nn_network then
        local inputs = get_neural_inputs(player)
        local yaw = entity.get_prop(player, "m_angEyeAngles[1]") or 0

        nn_network:train(inputs, {
            yaw / 100,     
            1,
            1,       
            1               
        })
    end

    resolver_data[player] = data
end

local function on_shot_missed(event)
    if not ui.get(ui_resolver_enabled) then
        return
    end

    local player = client.userid_to_entindex(event.target)
    if not player or not entity.is_alive(player) or not entity.is_enemy(player) then
        return
    end

    local data = resolver_data[player] or {}

    data.miss_count = (data.miss_count or 1) + 1

    data.confidence = math.max(50, (data.confidence or 100) - 10)

    if nn_network then
        local inputs = get_neural_inputs(player)
        local eye_angle_yaw = entity.get_prop(player, "m_angEyeAngles[1]") or 0
        nn_network:train(inputs, {eye_angle_yaw / 100, 1, 0, 0})
    end

    resolver_data[player] = data

    if ui.get(ui_new_logs_enable) then
        local reason = event.reason or "unknown"
        local hitgroup = event.hitgroup or 0
        local player_state = get_player_state(player) or "unknown"
        local aa_pattern = data.aa_pattern or "unknown"

        client.color_log(396, 244, 85,
            string.format("[SHIT] Miss: Enemy=%s, Reason=%s, Hitgroup=%d, State=%s, AA=%s, Confidence=%.0f, MissCount=%d",
                entity.get_player_name(player),
                reason,
                hitgroup,
                player_state,
                aa_pattern,
                data.confidence,
                data.miss_count
            )
        )
    end
end

client.set_event_callback('paint_ui', function()
    if not ui.get(ui_elements.neural_mode) or not ui.get(ui_elements.neural_visualization) then return end
    if not resolved_target or not entity.is_alive(resolved_target) then
    resolved_target = nil
    for _, enemy in ipairs(enemies) do
        if resolver_data[enemy] and (resolver_data[enemy].hit_count > 0 or resolver_data[enemy].miss_count < 3) then
            resolved_target = enemy
            client.log("[SHIT] Selected resolved_target: " .. entity.get_player_name(enemy))
            break
        end
    end
    if not resolved_target and #enemies > 0 then
        resolved_target = enemies[1]
        client.log("[SHIT] Fallback resolved_target: " .. entity.get_player_name(enemies[1]))
    end
    if not resolved_target then
        client.log("[SHIT] No resolved_target selected")
    end
end
    if not nn_network then
        client.log("[SHIT] Error: Neural network not initialized")
        return
    end
    local scr_w, scr_h = client.screen_size()
    renderer.text(scr_w - 300, scr_h - 50, 255, 255, 255, 255, nil, 0, "[N3R4z1m] Rendering Neural Network")
    nn_network:render()
end)
    end)
    if not success then
        client.log("[SHIT] Critical error in resolver: ", err)
    end
end

local kcwctf = 55
local function hpypcz(tnfnvy) local _ = 36 end
local function cxdjpi(pajdaq) local _ = 58 end
if false then local _ = 80 end
if true then local _ = 11 end
while false do local _ = 87 break end
local function cenfde(ngavie) local _ = 77 end
if true then local _ = 84 end
while false do local _ = 83 break end
local function xitavc(nibkwj) local _ = 61 end
if false then local _ = 77 end
local function cxrtkn(bbzhkk) local _ = 87 end
local function uribhr(scqdec) local _ = 80 end
local kcngpw = 61
while false do local _ = 100 break end
while false do local _ = 55 break end
local function ndicht(uytcim) local _ = 8 end
if true then local _ = 34 end
local function mecxen(hguiqy) local _ = 48 end
local eubdxy = 65
local function wmyrvz(kabnhi) local _ = 6 end
local function mwqtbi(hbircs) local _ = 29 end
local miwuvc = 48
local function klodsf(jrwgsr) local _ = 13 end
local gnhfgj = 32
if true then local _ = 81 end
local function hclwmp(wectcw) local _ = 28 end
local function vpbvoz(kfglvv) local _ = 67 end
if false then local _ = 50 end

        break
    end
end
local dummy = 1; dummy = dummy + 6;

 end)(...)
